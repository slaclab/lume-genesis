{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LUME-Genesis","text":"<p>Genesis tools for use in LUME</p>"},{"location":"#related-publications","title":"Related Publications","text":"<p>The lume-genesis package was used in the following publications:</p> <p>Very high brightness and power LCLS-II hard X-ray pulses  Aliaksei Halavanau, Franz-Josef Decker, Claudio Emma, Jackson Sheppard, and Claudio Pellegrini, J. Synchrotron Rad. (2019). 26 [https://doi.org/10.1107/S1600577519002492]</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installing-lume-genesis-via-conda-forge","title":"Installing lume-genesis via conda-forge","text":"<p>Installing <code>lume-genesis</code> from the <code>conda-forge</code> channel can be achieved by adding <code>conda-forge</code> to your channels with:</p> <pre><code>conda config --add channels conda-forge\n</code></pre> <p>Once the <code>conda-forge</code> channel has been enabled, <code>lume-genesis</code> can be installed with:</p> <pre><code>conda install lume-genesis\n</code></pre> <p>It is possible to list all of the versions of <code>lume-genesis</code> available on your platform with:</p> <pre><code>conda search lume-genesis --channel conda-forge\n</code></pre>"},{"location":"installation/#installing-genesis-13-version-2-executables","title":"Installing Genesis 1.3 version 2 Executables","text":"<p>See: slaclab/Genesis-1.3-Version2 Installation</p>"},{"location":"installation/#installing-genesis-13-version-4-executables","title":"Installing Genesis 1.3 version 4 Executables","text":"<p>See: svenreiche/Genesis-1.3-Version4 dev installation</p> <p>Please use the <code>dev</code> branch to be compatible with LUME-Genesis.</p> <p>Once built, set this environmental variable so that LUME-Genesis can find the executable: <pre><code>export GENESIS4_BIN=/path/to/build/genesis4\n</code></pre></p>"},{"location":"installation/#macos","title":"macOS","text":"<p>Installation on macOS requires a suitable compiler and dependencies, which can be provided by MacPorts. With a working MacPorts, install the GCC12 compiler and dependencies: <pre><code>sudo port install gcc12\nsudo port select gcc mp-gcc12\nsudo port install openmpi-gcc12\nsudo port select mpi openmpi-gcc12-fortran\nsudo port install hdf5 +openmpi \nsudo port install fftw-3\n</code></pre></p> <p>Get the latest Genesis4 code <pre><code>git clone https://github.com/svenreiche/Genesis-1.3-Version4\ncd Genesis-1.3-Version4/\ngit fetch \ngit swtich dev\n</code></pre></p> <p>Then build Genesis: <pre><code>cmake -S . -B build -DCMAKE_BUILD_TYPE=Release\ncmake --build build\n</code></pre></p>"},{"location":"installation/#genesis4-on-perlmutter-and-cori-nersc","title":"Genesis4 on Perlmutter and Cori (NERSC)","text":"<pre><code>git clone https://github.com/svenreiche/Genesis-1.3-Version4\ncd Genesis-1.3-Version4/\ngit fetch \ngit switch dev\nmodule load cray-hdf5-parallel\nmodule load cray-fftw\ncmake -S . -B build -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_COMPILER=CC\ncmake --build build\n</code></pre>"},{"location":"installation/#old-genesis-13-v20-installation","title":"Old Genesis 1.3 v2.0 Installation","text":"<p>Go to http://genesis.web.psi.ch/download.html and download: http://genesis.web.psi.ch/download/source/genesis_source_2.0_120629.tar.gz</p> <p>Untar, and replace one of the source files with one provided in this repository (cloned at ): <pre><code>  tar -xzvf genesis_source_2.0_120629.tar\n  cd  Genesis_Current\n  cp &lt;ROOT&gt;/lume-genesis/extra/fix_genesis_input/input.f .\n</code></pre> Edit Makefile to point to your compile, and type: <pre><code>make\n</code></pre> This should build the  <code>genesis</code> binary."},{"location":"installation/#developers","title":"Developers","text":"<p>Clone this repository: <pre><code>git clone https://github.com/slaclab/lume-genesis.git\n</code></pre></p> <p>Create an environment <code>genesis-dev</code> with all the dependencies: <pre><code>conda env create -f environment.yml\n</code></pre></p> <p>Install as editable: <pre><code>conda activate genesis-dev\npip install --no-dependencies -e .\n</code></pre></p>"},{"location":"api/genesis2/","title":"Genesis2","text":"<p>             Bases: <code>CommandWrapper</code></p> <p>Files will be written into a temporary directory within workdir. If workdir=None, a location will be determined by the system.</p> Source code in <code>genesis/genesis2.py</code> <pre><code>class Genesis2(CommandWrapper):\n    \"\"\"\n    Files will be written into a temporary directory within workdir.\n    If workdir=None, a location will be determined by the system.\n    \"\"\"\n\n    COMMAND = \"genesis2\"\n    COMMAND_MPI = \"genesis2-mpi\"\n\n    # Environmental variables to search for executables\n    command_env = \"GENESIS2_BIN\"\n    command_mpi_env = \"GENESIS2_MPI_BIN\"\n\n    def __init__(self, *args, group=None, **kwargs):\n        super().__init__(*args, **kwargs)\n        # Save init\n        self.original_input_file = self.input_file\n\n        self.input = {\"param\": None, \"beam\": None, \"lattice\": None}\n        self.output = {}\n        self.numprocs = 1\n\n        # Call configure\n        if self.input_file:\n            infile = lume_tools.full_path(self.input_file)\n            assert os.path.exists(\n                infile\n            ), f\"Genesis2 input file does not exist: {infile}\"\n            self.load_input(self.input_file)\n\n        else:\n            # Use default\n            self.input[\"param\"] = parsers.MAIN_INPUT_DEFAULT.copy()\n            self.vprint(\"Using default input\")\n        self.configure()\n\n    # Conveniences\n    @property\n    def beam(self):\n        return self.input[\"beam\"]\n\n    @property\n    def lattice(self):\n        return self.input[\"lattice\"]\n\n    @property\n    def param(self):\n        return self.input[\"param\"]\n\n    def configure(self):\n        self.setup_workdir(self._workdir)\n        self.input_file = os.path.join(self.path, \"genesis.in\")\n        self.vprint(\"Configured to run in:\", self.path)\n        self.configured = True\n\n    def input_parser(self, path):\n        return parsers.parse_genesis2_input(path)\n\n    def load_output(self):\n        fname = os.path.join(self.path, self.param[\"outputfile\"])\n        self.output = parsers.parse_genesis2_output(fname)\n\n    def plot(self):\n        raise NotImplementedError(\"Plot not yet implemented.\")\n\n    def run(self):\n        \"\"\"\n        Run Genesis2\n        \"\"\"\n\n        # Clear previous output\n        self.output = {}\n        run_info = self.output[\"run_info\"] = {\"error\": False}\n\n        t1 = time()\n        run_info[\"start_time\"] = t1\n\n        # Debugging\n        self.vprint(f\"Running genesis in {self.path}\")\n\n        # Write all input\n        self.write_input()\n\n        runscript = self.get_run_script()\n        run_info[\"run_script\"] = \" \".join(runscript)\n\n        try:\n            if self.timeout:\n                res = tools.execute2(runscript, timeout=self.timeout, cwd=self.path)\n                log = res[\"log\"]\n                self.error = res[\"error\"]\n                run_info[\"why_error\"] = res[\"why_error\"]\n            else:\n                # Interactive output, for Jupyter\n                log = []\n                for path in tools.execute(runscript, cwd=self.path):\n                    self.vprint(path, end=\"\")\n                    log.append(path)\n\n            self.log = log\n            self.error = False\n\n            self.load_output()\n\n        except Exception as ex:\n            print(\"Run Aborted\", ex)\n            error_str = traceback.format_exc()\n            self.error = True\n            run_info[\"why_error\"] = str(error_str)\n\n        finally:\n            run_info[\"run_time\"] = time() - t1\n            run_info[\"run_error\"] = self.error\n\n        self.finished = True\n\n    def write_input(self):\n        \"\"\"\n        Writes all input files\n        \"\"\"\n        self.write_input_file()\n\n        self.write_beam()\n        self.write_lattice()\n\n        # Write the run script\n        self.get_run_script()\n\n    def write_input_file(self):\n        \"\"\"\n        Write parameters to main .in file\n\n        \"\"\"\n        lines = tools.namelist_lines(self.param, start=\"$newrun\", end=\"$end\")\n\n        with open(self.input_file, \"w\") as f:\n            for line in lines:\n                f.write(line + \"\\n\")\n\n    def write_beam(self):\n        if not self.beam:\n            return\n\n        filePath = os.path.join(self.path, os.path.split(self.param[\"beamfile\"])[-1])\n        writers.write_beam_file(filePath, self.beam, verbose=self.verbose)\n\n    def write_lattice(self):\n        if not self.lattice:\n            self.vprint(\"Warning: no lattice to write\")\n            return\n\n        else:\n            filePath = os.path.join(self.path, self.param[\"maginfile\"])\n            lattice.write_lattice(filePath, self.lattice)\n            self.vprint(\"Lattice written:\", filePath)\n\n    def write_wavefront(self, h5=None):\n        \"\"\"\n        Write an openPMD wavefront from the dfl\n        \"\"\"\n\n        if not h5:\n            h5 = \"genesis_wavefront_\" + self.fingerprint() + \".h5\"\n\n        if isinstance(h5, str):\n            fname = os.path.expandvars(h5)\n            g = h5py.File(fname, \"w\")\n            self.vprint(f\"Writing wavefront (dfl data) to file {fname}\")\n        else:\n            g = h5\n\n        dfl = self.output[\"data\"][\"dfl\"]\n        param = self.output[\"param\"]\n        writers.write_openpmd_wavefront_h5(g, dfl=dfl, param=param)\n\n        return h5\n\n    def get_run_script(self, write_to_path=True):\n        \"\"\"\n        Assembles the run script usg self.mpi_run string of the form:\n            'mpirun -n {n} {command_mpi}'\n        Optionally writes a file 'run' with this line to path.\n        \"\"\"\n\n        n_procs = self.numprocs\n\n        exe = self.get_executable()\n\n        if self.use_mpi:\n            # mpi_exe could be a complicated string like:\n            # 'srun -N 1 --cpu_bind=cores {n} {command_mpi}'\n            # 'mpirun -n {n} {command_mpi}'\n\n            cmd = self.mpi_run.format(nproc=n_procs, command_mpi=exe)\n\n        else:\n            if n_procs &gt; 1:\n                raise ValueError(\"Error: n_procs &gt; 1 but use_mpi = False\")\n            cmd = exe\n\n        _, infile = os.path.split(self.input_file)\n\n        runscript = cmd.split() + [infile]\n\n        if write_to_path:\n            with open(os.path.join(self.path, \"run\"), \"w\") as f:\n                f.write(\" \".join(runscript))\n\n        return runscript\n\n    def get_executable(self):\n        \"\"\"\n        Gets the full path of the executable from .command, .command_mpi\n        Will search environmental variables:\n                Genesis2.command_env='GENESIS2_BIN'\n                Genesis2.command_mpi_env='GENESIS2_MPI_BIN'\n        \"\"\"\n        if self.use_mpi:\n            exe = lume_tools.find_executable(\n                exename=self.command_mpi, envname=self.command_mpi_env\n            )\n        else:\n            exe = lume_tools.find_executable(\n                exename=self.command, envname=self.command_env\n            )\n        return exe\n\n    def archive(self, h5=None):\n        \"\"\"\n        Archive all data to an h5 handle or filename.\n\n        If no file is given, a file based on the fingerprint will be created.\n\n        \"\"\"\n        if not h5:\n            h5 = \"genesis_\" + self.fingerprint() + \".h5\"\n\n        if isinstance(h5, str):\n            fname = os.path.expandvars(h5)\n            g = h5py.File(fname, \"w\")\n            self.vprint(f\"Archiving to file {fname}\")\n        else:\n            g = h5\n\n        # Write basic attributes\n        archive.genesis_init(g)\n\n        # All input\n        archive.write_input_h5(g, self.input, name=\"input\")\n\n        # All output\n        archive.write_output_h5(g, self.output, name=\"output\", verbose=self.verbose)\n\n        return h5\n\n    def load_archive(self, h5, configure=True):\n        \"\"\"\n        Loads input and output from archived h5 file.\n\n        See: Genesis.archive\n        \"\"\"\n        if isinstance(h5, str):\n            fname = os.path.expandvars(h5)\n            g = h5py.File(fname, \"r\")\n\n            glist = archive.find_genesis_archives(g)\n            n = len(glist)\n            if n == 0:\n                # legacy: try top level\n                message = \"legacy\"\n            elif n == 1:\n                gname = glist[0]\n                message = f\"group {gname} from\"\n                g = g[gname]\n            else:\n                raise ValueError(f\"Multiple archives found in file {fname}: {glist}\")\n\n            self.vprint(f\"Reading {message} archive file {h5}\")\n        else:\n            g = h5\n\n        self.input = archive.read_input_h5(g[\"input\"])\n        self.output = archive.read_output_h5(g[\"output\"], verbose=self.verbose)\n\n        self.vprint(\"Loaded from archive. Must reconfigure to run again.\")\n        self.configured = False\n\n        if configure:\n            self.configure()\n\n    def __getitem__(self, key):\n        \"\"\"\n        Convenience syntax to get an attribute\n\n        See: __setitem__\n        \"\"\"\n\n        if key in self.param:\n            return self.param[key]\n\n        raise ValueError(f\"{key} does not exist in input param\")\n\n    def __setitem__(self, key, item):\n        \"\"\"\n        Convenience syntax to set input parameters\n\n        Example:\n\n        G['ncar'] = 251\n\n        \"\"\"\n\n        if key in self.param:\n            self.param[key] = item\n        else:\n            raise ValueError(f\"{key} does not exist in input param\")\n\n    def __str__(self):\n        path = self.path\n        s = \"\"\n        if self.finished:\n            s += \"Genesis finished in \" + path\n        elif self.configured:\n            s += \"Genesis configured in \" + path\n        else:\n            s += \"Genesis not configured.\"\n        return s\n\n    def final_particles(self):\n        \"\"\"\n        Returns a ParticleGroup object from dpa data (if present)\n        \"\"\"\n        if \"dpa\" in self.output[\"data\"]:\n            return final_particles(self)\n        else:\n            return None\n</code></pre>"},{"location":"api/genesis2/#genesis.Genesis2.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Convenience syntax to get an attribute</p> <p>See: setitem</p> Source code in <code>genesis/genesis2.py</code> <pre><code>def __getitem__(self, key):\n    \"\"\"\n    Convenience syntax to get an attribute\n\n    See: __setitem__\n    \"\"\"\n\n    if key in self.param:\n        return self.param[key]\n\n    raise ValueError(f\"{key} does not exist in input param\")\n</code></pre>"},{"location":"api/genesis2/#genesis.Genesis2.__setitem__","title":"<code>__setitem__(key, item)</code>","text":"<p>Convenience syntax to set input parameters</p> <p>Example:</p> <p>G['ncar'] = 251</p> Source code in <code>genesis/genesis2.py</code> <pre><code>def __setitem__(self, key, item):\n    \"\"\"\n    Convenience syntax to set input parameters\n\n    Example:\n\n    G['ncar'] = 251\n\n    \"\"\"\n\n    if key in self.param:\n        self.param[key] = item\n    else:\n        raise ValueError(f\"{key} does not exist in input param\")\n</code></pre>"},{"location":"api/genesis2/#genesis.Genesis2.archive","title":"<code>archive(h5=None)</code>","text":"<p>Archive all data to an h5 handle or filename.</p> <p>If no file is given, a file based on the fingerprint will be created.</p> Source code in <code>genesis/genesis2.py</code> <pre><code>def archive(self, h5=None):\n    \"\"\"\n    Archive all data to an h5 handle or filename.\n\n    If no file is given, a file based on the fingerprint will be created.\n\n    \"\"\"\n    if not h5:\n        h5 = \"genesis_\" + self.fingerprint() + \".h5\"\n\n    if isinstance(h5, str):\n        fname = os.path.expandvars(h5)\n        g = h5py.File(fname, \"w\")\n        self.vprint(f\"Archiving to file {fname}\")\n    else:\n        g = h5\n\n    # Write basic attributes\n    archive.genesis_init(g)\n\n    # All input\n    archive.write_input_h5(g, self.input, name=\"input\")\n\n    # All output\n    archive.write_output_h5(g, self.output, name=\"output\", verbose=self.verbose)\n\n    return h5\n</code></pre>"},{"location":"api/genesis2/#genesis.Genesis2.final_particles","title":"<code>final_particles()</code>","text":"<p>Returns a ParticleGroup object from dpa data (if present)</p> Source code in <code>genesis/genesis2.py</code> <pre><code>def final_particles(self):\n    \"\"\"\n    Returns a ParticleGroup object from dpa data (if present)\n    \"\"\"\n    if \"dpa\" in self.output[\"data\"]:\n        return final_particles(self)\n    else:\n        return None\n</code></pre>"},{"location":"api/genesis2/#genesis.Genesis2.get_executable","title":"<code>get_executable()</code>","text":"<p>Gets the full path of the executable from .command, .command_mpi Will search environmental variables:         Genesis2.command_env='GENESIS2_BIN'         Genesis2.command_mpi_env='GENESIS2_MPI_BIN'</p> Source code in <code>genesis/genesis2.py</code> <pre><code>def get_executable(self):\n    \"\"\"\n    Gets the full path of the executable from .command, .command_mpi\n    Will search environmental variables:\n            Genesis2.command_env='GENESIS2_BIN'\n            Genesis2.command_mpi_env='GENESIS2_MPI_BIN'\n    \"\"\"\n    if self.use_mpi:\n        exe = lume_tools.find_executable(\n            exename=self.command_mpi, envname=self.command_mpi_env\n        )\n    else:\n        exe = lume_tools.find_executable(\n            exename=self.command, envname=self.command_env\n        )\n    return exe\n</code></pre>"},{"location":"api/genesis2/#genesis.Genesis2.get_run_script","title":"<code>get_run_script(write_to_path=True)</code>","text":"<p>Assembles the run script usg self.mpi_run string of the form:     'mpirun -n {n} {command_mpi}' Optionally writes a file 'run' with this line to path.</p> Source code in <code>genesis/genesis2.py</code> <pre><code>def get_run_script(self, write_to_path=True):\n    \"\"\"\n    Assembles the run script usg self.mpi_run string of the form:\n        'mpirun -n {n} {command_mpi}'\n    Optionally writes a file 'run' with this line to path.\n    \"\"\"\n\n    n_procs = self.numprocs\n\n    exe = self.get_executable()\n\n    if self.use_mpi:\n        # mpi_exe could be a complicated string like:\n        # 'srun -N 1 --cpu_bind=cores {n} {command_mpi}'\n        # 'mpirun -n {n} {command_mpi}'\n\n        cmd = self.mpi_run.format(nproc=n_procs, command_mpi=exe)\n\n    else:\n        if n_procs &gt; 1:\n            raise ValueError(\"Error: n_procs &gt; 1 but use_mpi = False\")\n        cmd = exe\n\n    _, infile = os.path.split(self.input_file)\n\n    runscript = cmd.split() + [infile]\n\n    if write_to_path:\n        with open(os.path.join(self.path, \"run\"), \"w\") as f:\n            f.write(\" \".join(runscript))\n\n    return runscript\n</code></pre>"},{"location":"api/genesis2/#genesis.Genesis2.load_archive","title":"<code>load_archive(h5, configure=True)</code>","text":"<p>Loads input and output from archived h5 file.</p> <p>See: Genesis.archive</p> Source code in <code>genesis/genesis2.py</code> <pre><code>def load_archive(self, h5, configure=True):\n    \"\"\"\n    Loads input and output from archived h5 file.\n\n    See: Genesis.archive\n    \"\"\"\n    if isinstance(h5, str):\n        fname = os.path.expandvars(h5)\n        g = h5py.File(fname, \"r\")\n\n        glist = archive.find_genesis_archives(g)\n        n = len(glist)\n        if n == 0:\n            # legacy: try top level\n            message = \"legacy\"\n        elif n == 1:\n            gname = glist[0]\n            message = f\"group {gname} from\"\n            g = g[gname]\n        else:\n            raise ValueError(f\"Multiple archives found in file {fname}: {glist}\")\n\n        self.vprint(f\"Reading {message} archive file {h5}\")\n    else:\n        g = h5\n\n    self.input = archive.read_input_h5(g[\"input\"])\n    self.output = archive.read_output_h5(g[\"output\"], verbose=self.verbose)\n\n    self.vprint(\"Loaded from archive. Must reconfigure to run again.\")\n    self.configured = False\n\n    if configure:\n        self.configure()\n</code></pre>"},{"location":"api/genesis2/#genesis.Genesis2.run","title":"<code>run()</code>","text":"<p>Run Genesis2</p> Source code in <code>genesis/genesis2.py</code> <pre><code>def run(self):\n    \"\"\"\n    Run Genesis2\n    \"\"\"\n\n    # Clear previous output\n    self.output = {}\n    run_info = self.output[\"run_info\"] = {\"error\": False}\n\n    t1 = time()\n    run_info[\"start_time\"] = t1\n\n    # Debugging\n    self.vprint(f\"Running genesis in {self.path}\")\n\n    # Write all input\n    self.write_input()\n\n    runscript = self.get_run_script()\n    run_info[\"run_script\"] = \" \".join(runscript)\n\n    try:\n        if self.timeout:\n            res = tools.execute2(runscript, timeout=self.timeout, cwd=self.path)\n            log = res[\"log\"]\n            self.error = res[\"error\"]\n            run_info[\"why_error\"] = res[\"why_error\"]\n        else:\n            # Interactive output, for Jupyter\n            log = []\n            for path in tools.execute(runscript, cwd=self.path):\n                self.vprint(path, end=\"\")\n                log.append(path)\n\n        self.log = log\n        self.error = False\n\n        self.load_output()\n\n    except Exception as ex:\n        print(\"Run Aborted\", ex)\n        error_str = traceback.format_exc()\n        self.error = True\n        run_info[\"why_error\"] = str(error_str)\n\n    finally:\n        run_info[\"run_time\"] = time() - t1\n        run_info[\"run_error\"] = self.error\n\n    self.finished = True\n</code></pre>"},{"location":"api/genesis2/#genesis.Genesis2.write_input","title":"<code>write_input()</code>","text":"<p>Writes all input files</p> Source code in <code>genesis/genesis2.py</code> <pre><code>def write_input(self):\n    \"\"\"\n    Writes all input files\n    \"\"\"\n    self.write_input_file()\n\n    self.write_beam()\n    self.write_lattice()\n\n    # Write the run script\n    self.get_run_script()\n</code></pre>"},{"location":"api/genesis2/#genesis.Genesis2.write_input_file","title":"<code>write_input_file()</code>","text":"<p>Write parameters to main .in file</p> Source code in <code>genesis/genesis2.py</code> <pre><code>def write_input_file(self):\n    \"\"\"\n    Write parameters to main .in file\n\n    \"\"\"\n    lines = tools.namelist_lines(self.param, start=\"$newrun\", end=\"$end\")\n\n    with open(self.input_file, \"w\") as f:\n        for line in lines:\n            f.write(line + \"\\n\")\n</code></pre>"},{"location":"api/genesis2/#genesis.Genesis2.write_wavefront","title":"<code>write_wavefront(h5=None)</code>","text":"<p>Write an openPMD wavefront from the dfl</p> Source code in <code>genesis/genesis2.py</code> <pre><code>def write_wavefront(self, h5=None):\n    \"\"\"\n    Write an openPMD wavefront from the dfl\n    \"\"\"\n\n    if not h5:\n        h5 = \"genesis_wavefront_\" + self.fingerprint() + \".h5\"\n\n    if isinstance(h5, str):\n        fname = os.path.expandvars(h5)\n        g = h5py.File(fname, \"w\")\n        self.vprint(f\"Writing wavefront (dfl data) to file {fname}\")\n    else:\n        g = h5\n\n    dfl = self.output[\"data\"][\"dfl\"]\n    param = self.output[\"param\"]\n    writers.write_openpmd_wavefront_h5(g, dfl=dfl, param=param)\n\n    return h5\n</code></pre>"},{"location":"api/genesis4/","title":"Genesis4","text":"<p>             Bases: <code>CommandWrapper</code></p> <p>Files will be written into a temporary directory within workdir. If workdir=None, a location will be determined by the system.</p>"},{"location":"api/genesis4/#genesis.Genesis4--parameters","title":"Parameters","text":"<p>input_file: str     Default: None</p> ParticleGroup <p>Default: None</p> str <p>Default: \"genesis4\"</p> str <p>Default: \"genesis4\"</p> bool <p>Default: False</p> str <p>Default: \"\"</p> bool <p>Default: True</p> path-like <p>Default: None</p> bool <p>Default: False</p> float <p>Default: None</p> Source code in <code>genesis/version4/genesis4.py</code> <pre><code>class Genesis4(CommandWrapper):\n    \"\"\"\n    Files will be written into a temporary directory within workdir.\n    If workdir=None, a location will be determined by the system.\n\n\n    Parameters\n    ---------\n    input_file: str\n        Default: None\n\n    initial_particle: ParticleGroup\n        Default: None\n\n    command: str\n        Default: \"genesis4\"\n\n    command_mpi: str\n        Default: \"genesis4\"\n\n    use_mpi: bool\n        Default: False\n\n    mpi_run: str\n        Default: \"\"\n\n    use_temp_dir: bool\n        Default: True\n\n    workdir: path-like\n        Default: None\n\n    verbose: bool\n        Default: False\n\n    timeout: float\n        Default: None\n\n\n    \"\"\"\n\n    COMMAND = \"genesis4\"\n    COMMAND_MPI = \"genesis4\"\n    MPI_RUN = find_mpirun()\n    WORKDIR = find_workdir()\n\n    # Environmental variables to search for executables\n    command_env = \"GENESIS4_BIN\"\n    command_mpi_env = \"GENESIS4_BIN\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # Save init\n        self.original_input_file = self.input_file\n\n        # Data\n        self.input = {\"main\": {}, \"lattice\": []}\n        self.output = {}\n\n        # Internal\n        self._units = parsers.known_unit.copy()\n        self._alias = {}\n\n        # MPI\n        self._nproc = 1\n        self._nnode = 1\n\n        # Call configure\n        if self.input_file:\n            infile = tools.full_path(self.input_file)\n            assert os.path.exists(infile), f\"Genesis input file does not exist: {infile}\"\n            self.load_input(self.input_file)\n            self.configure()\n\n        # else:\n        #    self.vprint('Using default input: 1 m drift lattice')\n        #    self.input = deepcopy(DEFAULT_INPUT)\n        #    self.configure()\n\n    def configure(self):\n        \"\"\"\n        Configure and set up for run.\n        \"\"\"\n\n    def configure(self):\n        self.setup_workdir(self._workdir)\n        self.vprint(\"Configured to run in:\", self.path)\n        self.configured = True\n\n    def run(self):\n        \"\"\"\n        Execute the code.\n        \"\"\"\n        # Auto-configure for convenience\n        if not self.configured:\n            self.configure()\n\n        # Clear output\n        self.output = {}\n\n        run_info = self.output[\"run_info\"] = {\"error\": False}\n\n        # Run script, gets executables\n        runscript = self.get_run_script()\n        run_info[\"run_script\"] = runscript\n\n        t1 = time()\n        run_info[\"start_time\"] = t1\n\n        self.vprint(f\"Running Genesis4 in {self.path}\")\n        self.vprint(runscript)\n\n        # Write input\n        self.write_input()\n\n        # TODO: Remove previous files\n\n        # try:\n        if self.timeout:\n            res = tools.execute2(runscript.split(), timeout=self.timeout, cwd=self.path)\n            log = res[\"log\"]\n            self.error = res[\"error\"]\n            run_info[\"error\"] = self.error\n            run_info[\"why_run_error\"] = res[\"why_error\"]\n\n        else:\n            # Interactive output, for Jupyter\n            log = []\n            counter = 0\n            for path in tools.execute(runscript.split(), cwd=self.path):\n                self.vprint(path, end=\"\")\n                # print(f'{path.strip()}, elapsed: {time()-t1:5.1f} s')\n                # # Fancy clearing of old lines\n                # counter +=1\n                # if self.verbose:\n                #     if counter &lt; 15:\n                #         print(path, end='')\n                #     else:\n                #         print('\\r', path.strip()+', elapsed: '+str(time()-t1), end='')\n                log.append(path)\n            self.vprint(\"Finished.\")\n        self.log = log\n\n        # Load output\n        self.load_output()\n\n        # except Exception as ex:\n        #    self.vprint('Exception in Genesis4:', ex)\n        #    run_info['error'] = True\n        #    run_info['why_run_error'] = str(ex)\n        # finally:\n        run_info[\"run_time\"] = time() - t1\n\n        self.finished = True\n\n    def get_executable(self):\n        \"\"\"\n        Gets the full path of the executable from .command, .command_mpi\n        Will search environmental variables:\n                Genesis4.command_env='GENESIS4_BIN'\n                Genesis4.command_mpi_env='GENESIS4_BIN'\n        \"\"\"\n        if self.use_mpi:\n            exe = tools.find_executable(\n                exename=self.command_mpi, envname=self.command_mpi_env\n            )\n        else:\n            exe = tools.find_executable(exename=self.command, envname=self.command_env)\n        return exe\n\n    def get_run_script(self, write_to_path=False, path=None, scriptname=\"run\"):\n        \"\"\"\n        Assembles the run script using self.mpi_run string of the form:\n            'mpirun -n {n} {command_mpi}'\n        Optionally writes a file 'run' with this line to path.\n\n        mpi_exe could be a complicated string like:\n            'srun -N 1 --cpu_bind=cores {n} {command_mpi}'\n            or\n            'mpirun -n {n} {command_mpi}'\n        \"\"\"\n        exe = self.get_executable()\n\n        # Expect to run locally\n        # _, infile = os.path.split(self.input_file)\n        infile = \"genesis4.in\"\n\n        if self.nproc &gt; 1 and not self.use_mpi:\n            self.vprint(f\"Setting use_mpi = True because nproc = {self.nproc}\")\n            self.use_mpi = True\n\n        if self.use_mpi:\n            runscript = [self.mpi_run.format(nnode=self.nnode, nproc=self.nproc, command_mpi=exe), infile]\n        else:\n            runscript = [exe, infile]\n\n        runscript = \" \".join(runscript)\n\n        if write_to_path:\n            if path is None:\n                path = self.path\n            path = os.path.join(path, scriptname)\n            with open(path, \"w\") as f:\n                f.write(runscript)\n            tools.make_executable(path)\n        return runscript\n\n    @property\n    def nproc(self):\n        \"\"\"\n        Number of MPI processes to use.\n        \"\"\"\n        return self._nproc\n\n    @nproc.setter\n    def nproc(self, n):\n        self._nproc = n\n\n    @property\n    def nnode(self):\n        \"\"\"\n        Number of MPI nodes to use\n        \"\"\"\n        return self._nnode\n\n    @nnode.setter\n    def nnode(self, n):\n        self._nnode = n        \n\n    @property\n    def particles(self):\n        return self.output[\"particles\"]        \n\n    @property\n    def field(self):\n        return self.output[\"field\"]\n\n    def units(self, key):\n        \"\"\"pmd_unit of a given key\"\"\"\n        if key in self._units:\n            return self._units[key]\n        else:\n            return None\n\n    def expand_alias(self, key):\n        if key in self._alias:\n            return self._alias[key]\n        else:\n            return key\n\n    def stat(self, key):\n        \"\"\"\n        Calculate a statistic of the beam or field\n        along z.\n        \"\"\"\n\n        # Derived stats\n        if key.startswith('beam_sigma_'):\n            comp = key[11:]\n            if comp not in ('x', 'px', 'y', 'py', 'energy'):\n                raise NotImplementedError(f\"Unsupported component for f{key}: '{comp}'\")\n\n            current = np.nan_to_num(self.output['Beam/current'])\n\n            if comp in ('x', 'y'):\n                k2 = f'Beam/{comp}size'\n                k1 = f'Beam/{comp}position'\n            elif comp in ('energy'):\n                k2 = f'Beam/energyspread'\n                k1 = f'Beam/energy'\n            else:\n                # TODO: emittance from alpha, beta, etc.\n                raise  NotImplementedError(f\"TODO: {key}\")\n            x2 = np.nan_to_num(self.output[k2]**2) # &lt;x^2&gt;_islice\n            x1 =  np.nan_to_num(self.output[k1]) # &lt;x&gt;_islice\n            sigma_X2 = projected_variance_from_slice_data(x2, x1, current)\n\n            return np.sqrt(sigma_X2) \n\n        # Original stats\n        key = self.expand_alias(key)\n\n        # Peak power\n        if 'power' in key.lower():\n            if 'field' in key.lower():\n                dat = self.output[key]\n            else:\n                dat = self.output['Field/power']\n            return np.max(dat, axis=1)\n\n        if key.startswith('Lattice'):\n            return self.get_array(key)\n\n        if key.startswith('Beam'):\n            dat = self.get_array(key)\n            skey = key.split('/')[1]\n\n            # Average over the beam taking to account the weighting (current)\n            current = np.nan_to_num(self.output['Beam/current'])\n\n            if skey in ('xsize', 'ysize'):\n                # TODO: emitx, emity\n                # Properly calculated the projected value\n                plane = skey[0]\n                x =  np.nan_to_num(self.output[f'Beam/{plane}position']) # &lt;x&gt;_islice\n                x2 = np.nan_to_num(self.output[f'Beam/{plane}size']**2) # &lt;x^2&gt;_islice\n                norm = np.sum(current, axis=1)\n                # Total projected sigma_x\n                sigma_x2 = np.sum( (x2 + x**2) * current, axis = 1)/norm - (np.sum(x * current, axis=1)/norm)**2\n\n                output = np.sqrt(sigma_x2)               \n            elif skey == 'bunching':\n                # The bunching calc needs to take the phase into account.\n                dat = np.nan_to_num(dat) # Convert any nan to zero for averaging.\n                phase = np.nan_to_num(self.output['Beam/bunchingphase'])\n                output = np.abs(np.sum(np.exp(1j*phase)*dat * current, axis=1)) / np.sum(current, axis=1)\n\n            else:\n                # Simple stat\n                dat = np.nan_to_num(dat) # Convert any nan to zero for averaging.\n                output = np.sum(dat * current, axis=1) / np.sum(current, axis=1)\n\n            return output\n\n        elif key.lower() in ['field_energy', 'pulse_energy']:\n            dat = self.output['Field/power']\n\n            # Integrate to get J\n            nslice = dat.shape[1]\n            slen = self.output['Global/slen']            \n            ds = slen/nslice\n            return np.sum(dat, axis=1) * ds / c_light\n\n        elif key.startswith('Field'):\n            dat = self.get_array(key)\n            skey = key.split('/')[1]\n            if skey in ['xposition', 'xsize',\n                        'yposition', 'ysize',\n                       ]:\n                return np.mean(dat, axis=1)\n\n\n\n        raise ValueError(f\"Cannot compute stat for: '{key}'\")\n\n\n\n    def get_array(self, key):\n        \"\"\"\n        Gets an array, considering aliases\n        \"\"\"\n        # Try raw\n        if key in self.output:\n            return self.output[key]\n        # Try alias\n        key = self.expand_alias(key)\n        if key in self.output:\n            return self.output[key]    \n\n        raise ValueError(f'unknwon key: {key}')\n\n\n\n\n    def archive(self, h5=None):\n        \"\"\"\n        Dump inputs and outputs into HDF5 file.\n\n        Parameters\n        ----------\n        h5 : str or h5py.File\n            The filename or handle to HDF5 file in which to write the information.\n            If not in informed, a new file is generated.\n\n        Returns\n        -------\n        h5 : h5py.File\n            Handle to the HDF5 file.\n        \"\"\"\n        if not h5:\n            h5 = \"genesis4_\" + self.fingerprint() + \".h5\"\n\n        if isinstance(h5, str):\n            if \"outfile\" in self.output:\n                shutil.copy(self.output[\"outfile\"], h5)\n                self.vprint(f\"Archiving to file {h5}\")\n\n            # fname = os.path.expandvars(h5)\n            # g = h5py.File(fname, 'w')\n            # self.vprint(f'Archiving to file {fname}')\n        else:\n            g = h5\n\n        return h5\n\n    def load_archive(self, h5, configure=True):\n        \"\"\"\n        Loads input and output from archived h5 file.\n\n        Parameters\n        ----------\n        h5 : str or h5py.File\n            The filename or handle on h5py.File from which to load input and output data\n        configure : bool, optional\n            Whether or not to invoke the configure method after loading, by default True\n        \"\"\"\n        raise NotImplementedError\n\n    def write_input(self, path=None, input_filename=\"genesis4.in\"):\n        \"\"\"\n        Write the input parameters into the file.\n\n        Parameters\n        ----------\n        input_filename : str\n            The file in which to write the input parameters\n        \"\"\"\n        if path is None:\n            path = self.path\n\n        assert os.path.exists(path)\n\n        filePath = os.path.join(path, input_filename)\n\n        # Write initial particles\n        self.write_initial_particles()\n\n        # Write main input file. This should come last.\n        writers.write_main_input(filePath, self.input[\"main\"])\n\n        # Write run script\n        self.get_run_script(write_to_path=True, path=path)\n\n    @staticmethod\n    def input_parser(path):\n        \"\"\"\n        Invoke the specialized input parser and returns the\n        input dictionary.\n\n        Parameters\n        ----------\n        path : str\n            Path to the input file\n\n        Returns\n        -------\n        input : dict\n            The input dictionary\n        \"\"\"\n        d = {}\n        d[\"main\"] = parsers.parse_main_input(path)\n\n        return d\n\n\n    def write_initial_particles(self, update_input=True, filename='genesis4_importdistribution.h5'):\n        \"\"\"\n        Writes initial particles (ParicleGroup) if present.\n\n        \"\"\"\n        p = self.initial_particles\n        if not p:\n            return\n\n        fout = os.path.join(self.path, filename)\n\n        # Particles\n        p.write_genesis4_distribution(fout)\n        self.vprint(f'Initial particles written to {fout}')\n\n        # Input\n        if update_input:\n            d1 = {'type': 'importdistribution',\n               'file': fout,\n               'charge': p.charge}            \n\n            main_input = self.input['main']\n\n\n            # Remove any existing 'beam', update slen\n            ixpop = []\n            for ix, d in enumerate(main_input):\n                if d['type'] == 'beam':\n                    ixpop.append(ix)\n                elif d['type'] == 'time':\n                    slen = max(c_light * p.t.ptp() , p.z.ptp() ) \n                    d['slen'] = slen\n                    self.vprint(f\"Updated slen = {slen}\")\n\n            if len(ixpop) &gt; 0:\n                if len(ixpop) &gt; 1:\n                    raise NotImplementedError(\"Multiple 'beam' encountered\")                    \n                main_input.pop(ixpop[0])\n                self.vprint(\"Removed 'beam' from input, will be replaced by 'importdistribution'\")\n            #else:\n            #    self.vprint('No existing beam encountered')\n\n            # look for existing importdistribution\n            for ix, d in enumerate(main_input):\n                if d['type'] == 'importdistribution':\n                    found = True\n                    d.update(d1)\n                    self.vprint(\"Updated existing importdistribution\")\n                    return\n\n            # Now try to insert before the first track or write statement\n            for ix, d in enumerate(main_input):\n                if d['type'] in ('track', 'write'):\n                    main_input.insert(ix, d1)          \n                    self.vprint(f\"Added new importdistribution before the first {d['type']}\")\n                    return\n\n\n\n            # Just append at the end. Note that a track will still be needed!\n            self.vprint(\"Nothing found, inserting at the end\")\n            main_input.append(d1)    \n\n    def load_output(self, load_fields=False, **kwargs):\n        \"\"\"\n        Reads and load into `.output` the outputs generated by the code.\n        \"\"\"\n\n        # Main ouput\n        outfile = self.input[\"main\"][0][\"rootname\"] + \".out.h5\"\n        outfile = os.path.join(self.path, outfile)\n        if not os.path.exists(outfile):\n            outfile = None\n            self.vprint(\"Warning: no main output file was created. Skipping.\")\n        self.output[\"outfile\"] = outfile\n\n        # Extract all data\n        if outfile:\n            self.vprint(f\"Loading main output: {outfile}\")\n            with h5py.File(outfile) as h5:\n                data, unit = parsers.extract_data_and_unit(h5)\n            self._units.update(unit)\n\n            for k, v in data.items():\n                self.output[k] = v        \n\n        # Find any field files\n        self.output[\"field\"] = {}\n        fld_files = [\n            os.path.join(self.path, f)\n            for f in os.listdir(self.path)\n            if f.endswith(\"fld.h5\")\n        ]\n        self.output[\"field_files\"] = sorted(fld_files, key = lambda k: parsers.dumpfile_step(k))\n\n        # Find any particle files\n        self.output[\"particles\"] = {}\n        par_files = [\n            os.path.join(self.path, f)\n            for f in os.listdir(self.path)\n            if f.endswith(\"par.h5\")\n        ]        \n        self.output[\"particle_files\"] = sorted(par_files, key = lambda k: parsers.dumpfile_step(k))\n\n\n\n        self._alias = parsers.extract_aliases(self.output)\n        for k, key in self._alias.items():\n            if key in self._units:\n                self._units[k] = self._units[key]\n\n    def load_particle_file(self, filename, smear=True):\n        \"\"\"\n        Loads a single particle file into openPMD-beamphysics\n        ParticleGroup object.\n\n        If smear = True (default), will smear the phase over \n        the sample (skipped) slices, preserving the modulus. \n        \"\"\"\n        P = ParticleGroup(data = genesis4_par_to_data(filename, smear=smear))\n\n        file = os.path.split(filename)[1]\n        if file.endswith(\"par.h5\"):\n            label = file[:-7]\n        else:\n            label = file\n\n        self.output[\"particles\"][label] = P\n        self.vprint(f\"Loaded particle data: '{label}' as a ParticleGroup with {len(P)} particles\")\n\n    def load_particles(self, smear=True):\n        \"\"\"\n        Loads all particle files produced.\n        \"\"\"\n        for file in self.output[\"particle_files\"]:\n            self.load_particle_file(file, smear=smear)        \n\n    def load_fields(self):\n        \"\"\"\n        Loads all field files produced.\n        \"\"\"\n        for file in self.output[\"field_files\"]:\n            self.load_field_file(file)\n\n\n    def load_field_file(self, filename):\n        \"\"\"\n        Load a single .dfl.h5 file into .output\n        \"\"\"\n        if not h5py.is_hdf5(filename):\n            raise ValueError(f\"Field file {filename} is not an HDF5 file\")\n        with h5py.File(filename, \"r\") as h5:\n            dfl, param = readers.load_genesis4_fields(h5)\n\n        file = os.path.split(filename)[1]\n        if file.endswith(\"fld.h5\"):\n            label = file[:-7]\n        else:\n            label = file\n\n        self.output[\"field\"][label] = {\"dfl\": dfl, \"param\": param}\n        self.vprint(f\"Loaded field data: {label}\")\n\n    def plot(\n        self,\n        y=\"field_energy\",\n        x=\"zplot\",\n        xlim=None,\n        ylim=None,\n        ylim2=None,\n        yscale='linear',\n        yscale2='linear',        \n        y2=[],\n        nice=True,\n        include_layout=True,\n        include_legend=True,\n        return_figure=False,\n        tex=False,\n        **kwargs,\n    ):\n        \"\"\"\n        Plots output multiple keys.\n\n        Parameters\n        ----------\n        y : list\n            List of keys to be displayed on the Y axis\n        x : str\n            Key to be displayed as X axis\n        xlim : list\n            Limits for the X axis\n        ylim : list\n            Limits for the Y axis\n        ylim2 : list\n            Limits for the secondary Y axis\n        yscale: str\n            one of \"linear\", \"log\", \"symlog\", \"logit\", ... for the Y axis\n        yscale2: str\n            one of \"linear\", \"log\", \"symlog\", \"logit\", ... for the secondary Y axis      \n        y2 : list\n            List of keys to be displayed on the secondary Y axis\n        nice : bool\n            Whether or not a nice SI prefix and scaling will be used to\n            make the numbers reasonably sized. Default: True\n        include_layout : bool\n            Whether or not to include a layout plot at the bottom. Default: True\n            Whether or not the plot should include the legend. Default: True\n        return_figure : bool\n            Whether or not to return the figure object for further manipulation.\n            Default: True\n        kwargs : dict\n            Extra arguments can be passed to the specific plotting function.\n\n        Returns\n        -------\n        fig : matplotlib.pyplot.figure.Figure\n            The plot figure for further customizations or `None` if `return_figure` is set to False.\n        \"\"\"\n\n\n        # Expand keys\n        if isinstance(y, str):\n            y = y.split()\n        if isinstance(y2, str):            \n            y2 = y2.split()\n\n        # Special case\n        for yk in (y, y2):\n            for i, key in enumerate(yk):\n                if 'power' in key:\n                    yk[i] = 'peak_power'   \n\n        return plot_stats_with_layout(\n            self,\n            ykeys=y,\n            ykeys2=y2,\n            xkey=x,\n            xlim=xlim,\n            ylim=ylim,\n            ylim2=ylim2,\n            yscale=yscale,\n            yscale2=yscale2,\n            nice=nice,\n            tex=tex,\n            include_layout=include_layout,\n            include_legend=include_legend,\n            return_figure=return_figure,\n            **kwargs,\n        )\n\n\n    def output_info(self):\n        print('Output data\\n')\n        print(\"key                       value              unit\")\n        print(50*'-')\n        for k in sorted(list(self.output)):\n            line = self.output_description_line(k)\n            print(line)\n\n\n    def output_description_line(self, k):\n        \"\"\"\n        Returns a line describing an output\n        \"\"\"\n        v = self.output[k]\n        u = self.units(k)\n        if u is None:\n            u = ''\n\n        if isinstance(v, dict):\n            return ''\n\n        if isinstance(v, str):\n            if len(v) &gt; 200:\n                descrip = 'long str: '+ v[0:20].replace('\\n', ' ') + '...'\n            else:\n                descrip = v  \n        elif np.isscalar(v):\n            descrip = f'{v} {u} '\n        elif isinstance(v, np.ndarray):\n            descrip = f'array: {str(v.shape):10}  {u}'\n        elif isinstance(v, list):\n            descrip = str(v)\n        else:\n            raise ValueError(f'Cannot describe {k}')\n\n\n        line = f'{k:25} {descrip}'\n        return line    \n</code></pre>"},{"location":"api/genesis4/#genesis.Genesis4.nnode","title":"<code>nnode</code>  <code>property</code> <code>writable</code>","text":"<p>Number of MPI nodes to use</p>"},{"location":"api/genesis4/#genesis.Genesis4.nproc","title":"<code>nproc</code>  <code>property</code> <code>writable</code>","text":"<p>Number of MPI processes to use.</p>"},{"location":"api/genesis4/#genesis.Genesis4.archive","title":"<code>archive(h5=None)</code>","text":"<p>Dump inputs and outputs into HDF5 file.</p>"},{"location":"api/genesis4/#genesis.Genesis4.archive--parameters","title":"Parameters","text":"<p>h5 : str or h5py.File     The filename or handle to HDF5 file in which to write the information.     If not in informed, a new file is generated.</p>"},{"location":"api/genesis4/#genesis.Genesis4.archive--returns","title":"Returns","text":"<p>h5 : h5py.File     Handle to the HDF5 file.</p> Source code in <code>genesis/version4/genesis4.py</code> <pre><code>def archive(self, h5=None):\n    \"\"\"\n    Dump inputs and outputs into HDF5 file.\n\n    Parameters\n    ----------\n    h5 : str or h5py.File\n        The filename or handle to HDF5 file in which to write the information.\n        If not in informed, a new file is generated.\n\n    Returns\n    -------\n    h5 : h5py.File\n        Handle to the HDF5 file.\n    \"\"\"\n    if not h5:\n        h5 = \"genesis4_\" + self.fingerprint() + \".h5\"\n\n    if isinstance(h5, str):\n        if \"outfile\" in self.output:\n            shutil.copy(self.output[\"outfile\"], h5)\n            self.vprint(f\"Archiving to file {h5}\")\n\n        # fname = os.path.expandvars(h5)\n        # g = h5py.File(fname, 'w')\n        # self.vprint(f'Archiving to file {fname}')\n    else:\n        g = h5\n\n    return h5\n</code></pre>"},{"location":"api/genesis4/#genesis.Genesis4.get_array","title":"<code>get_array(key)</code>","text":"<p>Gets an array, considering aliases</p> Source code in <code>genesis/version4/genesis4.py</code> <pre><code>def get_array(self, key):\n    \"\"\"\n    Gets an array, considering aliases\n    \"\"\"\n    # Try raw\n    if key in self.output:\n        return self.output[key]\n    # Try alias\n    key = self.expand_alias(key)\n    if key in self.output:\n        return self.output[key]    \n\n    raise ValueError(f'unknwon key: {key}')\n</code></pre>"},{"location":"api/genesis4/#genesis.Genesis4.get_executable","title":"<code>get_executable()</code>","text":"<p>Gets the full path of the executable from .command, .command_mpi Will search environmental variables:         Genesis4.command_env='GENESIS4_BIN'         Genesis4.command_mpi_env='GENESIS4_BIN'</p> Source code in <code>genesis/version4/genesis4.py</code> <pre><code>def get_executable(self):\n    \"\"\"\n    Gets the full path of the executable from .command, .command_mpi\n    Will search environmental variables:\n            Genesis4.command_env='GENESIS4_BIN'\n            Genesis4.command_mpi_env='GENESIS4_BIN'\n    \"\"\"\n    if self.use_mpi:\n        exe = tools.find_executable(\n            exename=self.command_mpi, envname=self.command_mpi_env\n        )\n    else:\n        exe = tools.find_executable(exename=self.command, envname=self.command_env)\n    return exe\n</code></pre>"},{"location":"api/genesis4/#genesis.Genesis4.get_run_script","title":"<code>get_run_script(write_to_path=False, path=None, scriptname='run')</code>","text":"<p>Assembles the run script using self.mpi_run string of the form:     'mpirun -n {n} {command_mpi}' Optionally writes a file 'run' with this line to path.</p> mpi_exe could be a complicated string like <p>'srun -N 1 --cpu_bind=cores {n} {command_mpi}' or 'mpirun -n {n} {command_mpi}'</p> Source code in <code>genesis/version4/genesis4.py</code> <pre><code>def get_run_script(self, write_to_path=False, path=None, scriptname=\"run\"):\n    \"\"\"\n    Assembles the run script using self.mpi_run string of the form:\n        'mpirun -n {n} {command_mpi}'\n    Optionally writes a file 'run' with this line to path.\n\n    mpi_exe could be a complicated string like:\n        'srun -N 1 --cpu_bind=cores {n} {command_mpi}'\n        or\n        'mpirun -n {n} {command_mpi}'\n    \"\"\"\n    exe = self.get_executable()\n\n    # Expect to run locally\n    # _, infile = os.path.split(self.input_file)\n    infile = \"genesis4.in\"\n\n    if self.nproc &gt; 1 and not self.use_mpi:\n        self.vprint(f\"Setting use_mpi = True because nproc = {self.nproc}\")\n        self.use_mpi = True\n\n    if self.use_mpi:\n        runscript = [self.mpi_run.format(nnode=self.nnode, nproc=self.nproc, command_mpi=exe), infile]\n    else:\n        runscript = [exe, infile]\n\n    runscript = \" \".join(runscript)\n\n    if write_to_path:\n        if path is None:\n            path = self.path\n        path = os.path.join(path, scriptname)\n        with open(path, \"w\") as f:\n            f.write(runscript)\n        tools.make_executable(path)\n    return runscript\n</code></pre>"},{"location":"api/genesis4/#genesis.Genesis4.input_parser","title":"<code>input_parser(path)</code>  <code>staticmethod</code>","text":"<p>Invoke the specialized input parser and returns the input dictionary.</p>"},{"location":"api/genesis4/#genesis.Genesis4.input_parser--parameters","title":"Parameters","text":"<p>path : str     Path to the input file</p>"},{"location":"api/genesis4/#genesis.Genesis4.input_parser--returns","title":"Returns","text":"<p>input : dict     The input dictionary</p> Source code in <code>genesis/version4/genesis4.py</code> <pre><code>@staticmethod\ndef input_parser(path):\n    \"\"\"\n    Invoke the specialized input parser and returns the\n    input dictionary.\n\n    Parameters\n    ----------\n    path : str\n        Path to the input file\n\n    Returns\n    -------\n    input : dict\n        The input dictionary\n    \"\"\"\n    d = {}\n    d[\"main\"] = parsers.parse_main_input(path)\n\n    return d\n</code></pre>"},{"location":"api/genesis4/#genesis.Genesis4.load_archive","title":"<code>load_archive(h5, configure=True)</code>","text":"<p>Loads input and output from archived h5 file.</p>"},{"location":"api/genesis4/#genesis.Genesis4.load_archive--parameters","title":"Parameters","text":"<p>h5 : str or h5py.File     The filename or handle on h5py.File from which to load input and output data configure : bool, optional     Whether or not to invoke the configure method after loading, by default True</p> Source code in <code>genesis/version4/genesis4.py</code> <pre><code>def load_archive(self, h5, configure=True):\n    \"\"\"\n    Loads input and output from archived h5 file.\n\n    Parameters\n    ----------\n    h5 : str or h5py.File\n        The filename or handle on h5py.File from which to load input and output data\n    configure : bool, optional\n        Whether or not to invoke the configure method after loading, by default True\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/genesis4/#genesis.Genesis4.load_field_file","title":"<code>load_field_file(filename)</code>","text":"<p>Load a single .dfl.h5 file into .output</p> Source code in <code>genesis/version4/genesis4.py</code> <pre><code>def load_field_file(self, filename):\n    \"\"\"\n    Load a single .dfl.h5 file into .output\n    \"\"\"\n    if not h5py.is_hdf5(filename):\n        raise ValueError(f\"Field file {filename} is not an HDF5 file\")\n    with h5py.File(filename, \"r\") as h5:\n        dfl, param = readers.load_genesis4_fields(h5)\n\n    file = os.path.split(filename)[1]\n    if file.endswith(\"fld.h5\"):\n        label = file[:-7]\n    else:\n        label = file\n\n    self.output[\"field\"][label] = {\"dfl\": dfl, \"param\": param}\n    self.vprint(f\"Loaded field data: {label}\")\n</code></pre>"},{"location":"api/genesis4/#genesis.Genesis4.load_fields","title":"<code>load_fields()</code>","text":"<p>Loads all field files produced.</p> Source code in <code>genesis/version4/genesis4.py</code> <pre><code>def load_fields(self):\n    \"\"\"\n    Loads all field files produced.\n    \"\"\"\n    for file in self.output[\"field_files\"]:\n        self.load_field_file(file)\n</code></pre>"},{"location":"api/genesis4/#genesis.Genesis4.load_output","title":"<code>load_output(load_fields=False, **kwargs)</code>","text":"<p>Reads and load into <code>.output</code> the outputs generated by the code.</p> Source code in <code>genesis/version4/genesis4.py</code> <pre><code>def load_output(self, load_fields=False, **kwargs):\n    \"\"\"\n    Reads and load into `.output` the outputs generated by the code.\n    \"\"\"\n\n    # Main ouput\n    outfile = self.input[\"main\"][0][\"rootname\"] + \".out.h5\"\n    outfile = os.path.join(self.path, outfile)\n    if not os.path.exists(outfile):\n        outfile = None\n        self.vprint(\"Warning: no main output file was created. Skipping.\")\n    self.output[\"outfile\"] = outfile\n\n    # Extract all data\n    if outfile:\n        self.vprint(f\"Loading main output: {outfile}\")\n        with h5py.File(outfile) as h5:\n            data, unit = parsers.extract_data_and_unit(h5)\n        self._units.update(unit)\n\n        for k, v in data.items():\n            self.output[k] = v        \n\n    # Find any field files\n    self.output[\"field\"] = {}\n    fld_files = [\n        os.path.join(self.path, f)\n        for f in os.listdir(self.path)\n        if f.endswith(\"fld.h5\")\n    ]\n    self.output[\"field_files\"] = sorted(fld_files, key = lambda k: parsers.dumpfile_step(k))\n\n    # Find any particle files\n    self.output[\"particles\"] = {}\n    par_files = [\n        os.path.join(self.path, f)\n        for f in os.listdir(self.path)\n        if f.endswith(\"par.h5\")\n    ]        \n    self.output[\"particle_files\"] = sorted(par_files, key = lambda k: parsers.dumpfile_step(k))\n\n\n\n    self._alias = parsers.extract_aliases(self.output)\n    for k, key in self._alias.items():\n        if key in self._units:\n            self._units[k] = self._units[key]\n</code></pre>"},{"location":"api/genesis4/#genesis.Genesis4.load_particle_file","title":"<code>load_particle_file(filename, smear=True)</code>","text":"<p>Loads a single particle file into openPMD-beamphysics ParticleGroup object.</p> <p>If smear = True (default), will smear the phase over  the sample (skipped) slices, preserving the modulus.</p> Source code in <code>genesis/version4/genesis4.py</code> <pre><code>def load_particle_file(self, filename, smear=True):\n    \"\"\"\n    Loads a single particle file into openPMD-beamphysics\n    ParticleGroup object.\n\n    If smear = True (default), will smear the phase over \n    the sample (skipped) slices, preserving the modulus. \n    \"\"\"\n    P = ParticleGroup(data = genesis4_par_to_data(filename, smear=smear))\n\n    file = os.path.split(filename)[1]\n    if file.endswith(\"par.h5\"):\n        label = file[:-7]\n    else:\n        label = file\n\n    self.output[\"particles\"][label] = P\n    self.vprint(f\"Loaded particle data: '{label}' as a ParticleGroup with {len(P)} particles\")\n</code></pre>"},{"location":"api/genesis4/#genesis.Genesis4.load_particles","title":"<code>load_particles(smear=True)</code>","text":"<p>Loads all particle files produced.</p> Source code in <code>genesis/version4/genesis4.py</code> <pre><code>def load_particles(self, smear=True):\n    \"\"\"\n    Loads all particle files produced.\n    \"\"\"\n    for file in self.output[\"particle_files\"]:\n        self.load_particle_file(file, smear=smear)        \n</code></pre>"},{"location":"api/genesis4/#genesis.Genesis4.output_description_line","title":"<code>output_description_line(k)</code>","text":"<p>Returns a line describing an output</p> Source code in <code>genesis/version4/genesis4.py</code> <pre><code>def output_description_line(self, k):\n    \"\"\"\n    Returns a line describing an output\n    \"\"\"\n    v = self.output[k]\n    u = self.units(k)\n    if u is None:\n        u = ''\n\n    if isinstance(v, dict):\n        return ''\n\n    if isinstance(v, str):\n        if len(v) &gt; 200:\n            descrip = 'long str: '+ v[0:20].replace('\\n', ' ') + '...'\n        else:\n            descrip = v  \n    elif np.isscalar(v):\n        descrip = f'{v} {u} '\n    elif isinstance(v, np.ndarray):\n        descrip = f'array: {str(v.shape):10}  {u}'\n    elif isinstance(v, list):\n        descrip = str(v)\n    else:\n        raise ValueError(f'Cannot describe {k}')\n\n\n    line = f'{k:25} {descrip}'\n    return line    \n</code></pre>"},{"location":"api/genesis4/#genesis.Genesis4.plot","title":"<code>plot(y='field_energy', x='zplot', xlim=None, ylim=None, ylim2=None, yscale='linear', yscale2='linear', y2=[], nice=True, include_layout=True, include_legend=True, return_figure=False, tex=False, **kwargs)</code>","text":"<p>Plots output multiple keys.</p>"},{"location":"api/genesis4/#genesis.Genesis4.plot--parameters","title":"Parameters","text":"<p>y : list     List of keys to be displayed on the Y axis x : str     Key to be displayed as X axis xlim : list     Limits for the X axis ylim : list     Limits for the Y axis ylim2 : list     Limits for the secondary Y axis yscale: str     one of \"linear\", \"log\", \"symlog\", \"logit\", ... for the Y axis yscale2: str     one of \"linear\", \"log\", \"symlog\", \"logit\", ... for the secondary Y axis     y2 : list     List of keys to be displayed on the secondary Y axis nice : bool     Whether or not a nice SI prefix and scaling will be used to     make the numbers reasonably sized. Default: True include_layout : bool     Whether or not to include a layout plot at the bottom. Default: True     Whether or not the plot should include the legend. Default: True return_figure : bool     Whether or not to return the figure object for further manipulation.     Default: True kwargs : dict     Extra arguments can be passed to the specific plotting function.</p>"},{"location":"api/genesis4/#genesis.Genesis4.plot--returns","title":"Returns","text":"<p>fig : matplotlib.pyplot.figure.Figure     The plot figure for further customizations or <code>None</code> if <code>return_figure</code> is set to False.</p> Source code in <code>genesis/version4/genesis4.py</code> <pre><code>def plot(\n    self,\n    y=\"field_energy\",\n    x=\"zplot\",\n    xlim=None,\n    ylim=None,\n    ylim2=None,\n    yscale='linear',\n    yscale2='linear',        \n    y2=[],\n    nice=True,\n    include_layout=True,\n    include_legend=True,\n    return_figure=False,\n    tex=False,\n    **kwargs,\n):\n    \"\"\"\n    Plots output multiple keys.\n\n    Parameters\n    ----------\n    y : list\n        List of keys to be displayed on the Y axis\n    x : str\n        Key to be displayed as X axis\n    xlim : list\n        Limits for the X axis\n    ylim : list\n        Limits for the Y axis\n    ylim2 : list\n        Limits for the secondary Y axis\n    yscale: str\n        one of \"linear\", \"log\", \"symlog\", \"logit\", ... for the Y axis\n    yscale2: str\n        one of \"linear\", \"log\", \"symlog\", \"logit\", ... for the secondary Y axis      \n    y2 : list\n        List of keys to be displayed on the secondary Y axis\n    nice : bool\n        Whether or not a nice SI prefix and scaling will be used to\n        make the numbers reasonably sized. Default: True\n    include_layout : bool\n        Whether or not to include a layout plot at the bottom. Default: True\n        Whether or not the plot should include the legend. Default: True\n    return_figure : bool\n        Whether or not to return the figure object for further manipulation.\n        Default: True\n    kwargs : dict\n        Extra arguments can be passed to the specific plotting function.\n\n    Returns\n    -------\n    fig : matplotlib.pyplot.figure.Figure\n        The plot figure for further customizations or `None` if `return_figure` is set to False.\n    \"\"\"\n\n\n    # Expand keys\n    if isinstance(y, str):\n        y = y.split()\n    if isinstance(y2, str):            \n        y2 = y2.split()\n\n    # Special case\n    for yk in (y, y2):\n        for i, key in enumerate(yk):\n            if 'power' in key:\n                yk[i] = 'peak_power'   \n\n    return plot_stats_with_layout(\n        self,\n        ykeys=y,\n        ykeys2=y2,\n        xkey=x,\n        xlim=xlim,\n        ylim=ylim,\n        ylim2=ylim2,\n        yscale=yscale,\n        yscale2=yscale2,\n        nice=nice,\n        tex=tex,\n        include_layout=include_layout,\n        include_legend=include_legend,\n        return_figure=return_figure,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/genesis4/#genesis.Genesis4.run","title":"<code>run()</code>","text":"<p>Execute the code.</p> Source code in <code>genesis/version4/genesis4.py</code> <pre><code>def run(self):\n    \"\"\"\n    Execute the code.\n    \"\"\"\n    # Auto-configure for convenience\n    if not self.configured:\n        self.configure()\n\n    # Clear output\n    self.output = {}\n\n    run_info = self.output[\"run_info\"] = {\"error\": False}\n\n    # Run script, gets executables\n    runscript = self.get_run_script()\n    run_info[\"run_script\"] = runscript\n\n    t1 = time()\n    run_info[\"start_time\"] = t1\n\n    self.vprint(f\"Running Genesis4 in {self.path}\")\n    self.vprint(runscript)\n\n    # Write input\n    self.write_input()\n\n    # TODO: Remove previous files\n\n    # try:\n    if self.timeout:\n        res = tools.execute2(runscript.split(), timeout=self.timeout, cwd=self.path)\n        log = res[\"log\"]\n        self.error = res[\"error\"]\n        run_info[\"error\"] = self.error\n        run_info[\"why_run_error\"] = res[\"why_error\"]\n\n    else:\n        # Interactive output, for Jupyter\n        log = []\n        counter = 0\n        for path in tools.execute(runscript.split(), cwd=self.path):\n            self.vprint(path, end=\"\")\n            # print(f'{path.strip()}, elapsed: {time()-t1:5.1f} s')\n            # # Fancy clearing of old lines\n            # counter +=1\n            # if self.verbose:\n            #     if counter &lt; 15:\n            #         print(path, end='')\n            #     else:\n            #         print('\\r', path.strip()+', elapsed: '+str(time()-t1), end='')\n            log.append(path)\n        self.vprint(\"Finished.\")\n    self.log = log\n\n    # Load output\n    self.load_output()\n\n    # except Exception as ex:\n    #    self.vprint('Exception in Genesis4:', ex)\n    #    run_info['error'] = True\n    #    run_info['why_run_error'] = str(ex)\n    # finally:\n    run_info[\"run_time\"] = time() - t1\n\n    self.finished = True\n</code></pre>"},{"location":"api/genesis4/#genesis.Genesis4.stat","title":"<code>stat(key)</code>","text":"<p>Calculate a statistic of the beam or field along z.</p> Source code in <code>genesis/version4/genesis4.py</code> <pre><code>def stat(self, key):\n    \"\"\"\n    Calculate a statistic of the beam or field\n    along z.\n    \"\"\"\n\n    # Derived stats\n    if key.startswith('beam_sigma_'):\n        comp = key[11:]\n        if comp not in ('x', 'px', 'y', 'py', 'energy'):\n            raise NotImplementedError(f\"Unsupported component for f{key}: '{comp}'\")\n\n        current = np.nan_to_num(self.output['Beam/current'])\n\n        if comp in ('x', 'y'):\n            k2 = f'Beam/{comp}size'\n            k1 = f'Beam/{comp}position'\n        elif comp in ('energy'):\n            k2 = f'Beam/energyspread'\n            k1 = f'Beam/energy'\n        else:\n            # TODO: emittance from alpha, beta, etc.\n            raise  NotImplementedError(f\"TODO: {key}\")\n        x2 = np.nan_to_num(self.output[k2]**2) # &lt;x^2&gt;_islice\n        x1 =  np.nan_to_num(self.output[k1]) # &lt;x&gt;_islice\n        sigma_X2 = projected_variance_from_slice_data(x2, x1, current)\n\n        return np.sqrt(sigma_X2) \n\n    # Original stats\n    key = self.expand_alias(key)\n\n    # Peak power\n    if 'power' in key.lower():\n        if 'field' in key.lower():\n            dat = self.output[key]\n        else:\n            dat = self.output['Field/power']\n        return np.max(dat, axis=1)\n\n    if key.startswith('Lattice'):\n        return self.get_array(key)\n\n    if key.startswith('Beam'):\n        dat = self.get_array(key)\n        skey = key.split('/')[1]\n\n        # Average over the beam taking to account the weighting (current)\n        current = np.nan_to_num(self.output['Beam/current'])\n\n        if skey in ('xsize', 'ysize'):\n            # TODO: emitx, emity\n            # Properly calculated the projected value\n            plane = skey[0]\n            x =  np.nan_to_num(self.output[f'Beam/{plane}position']) # &lt;x&gt;_islice\n            x2 = np.nan_to_num(self.output[f'Beam/{plane}size']**2) # &lt;x^2&gt;_islice\n            norm = np.sum(current, axis=1)\n            # Total projected sigma_x\n            sigma_x2 = np.sum( (x2 + x**2) * current, axis = 1)/norm - (np.sum(x * current, axis=1)/norm)**2\n\n            output = np.sqrt(sigma_x2)               \n        elif skey == 'bunching':\n            # The bunching calc needs to take the phase into account.\n            dat = np.nan_to_num(dat) # Convert any nan to zero for averaging.\n            phase = np.nan_to_num(self.output['Beam/bunchingphase'])\n            output = np.abs(np.sum(np.exp(1j*phase)*dat * current, axis=1)) / np.sum(current, axis=1)\n\n        else:\n            # Simple stat\n            dat = np.nan_to_num(dat) # Convert any nan to zero for averaging.\n            output = np.sum(dat * current, axis=1) / np.sum(current, axis=1)\n\n        return output\n\n    elif key.lower() in ['field_energy', 'pulse_energy']:\n        dat = self.output['Field/power']\n\n        # Integrate to get J\n        nslice = dat.shape[1]\n        slen = self.output['Global/slen']            \n        ds = slen/nslice\n        return np.sum(dat, axis=1) * ds / c_light\n\n    elif key.startswith('Field'):\n        dat = self.get_array(key)\n        skey = key.split('/')[1]\n        if skey in ['xposition', 'xsize',\n                    'yposition', 'ysize',\n                   ]:\n            return np.mean(dat, axis=1)\n\n\n\n    raise ValueError(f\"Cannot compute stat for: '{key}'\")\n</code></pre>"},{"location":"api/genesis4/#genesis.Genesis4.units","title":"<code>units(key)</code>","text":"<p>pmd_unit of a given key</p> Source code in <code>genesis/version4/genesis4.py</code> <pre><code>def units(self, key):\n    \"\"\"pmd_unit of a given key\"\"\"\n    if key in self._units:\n        return self._units[key]\n    else:\n        return None\n</code></pre>"},{"location":"api/genesis4/#genesis.Genesis4.write_initial_particles","title":"<code>write_initial_particles(update_input=True, filename='genesis4_importdistribution.h5')</code>","text":"<p>Writes initial particles (ParicleGroup) if present.</p> Source code in <code>genesis/version4/genesis4.py</code> <pre><code>def write_initial_particles(self, update_input=True, filename='genesis4_importdistribution.h5'):\n    \"\"\"\n    Writes initial particles (ParicleGroup) if present.\n\n    \"\"\"\n    p = self.initial_particles\n    if not p:\n        return\n\n    fout = os.path.join(self.path, filename)\n\n    # Particles\n    p.write_genesis4_distribution(fout)\n    self.vprint(f'Initial particles written to {fout}')\n\n    # Input\n    if update_input:\n        d1 = {'type': 'importdistribution',\n           'file': fout,\n           'charge': p.charge}            \n\n        main_input = self.input['main']\n\n\n        # Remove any existing 'beam', update slen\n        ixpop = []\n        for ix, d in enumerate(main_input):\n            if d['type'] == 'beam':\n                ixpop.append(ix)\n            elif d['type'] == 'time':\n                slen = max(c_light * p.t.ptp() , p.z.ptp() ) \n                d['slen'] = slen\n                self.vprint(f\"Updated slen = {slen}\")\n\n        if len(ixpop) &gt; 0:\n            if len(ixpop) &gt; 1:\n                raise NotImplementedError(\"Multiple 'beam' encountered\")                    \n            main_input.pop(ixpop[0])\n            self.vprint(\"Removed 'beam' from input, will be replaced by 'importdistribution'\")\n        #else:\n        #    self.vprint('No existing beam encountered')\n\n        # look for existing importdistribution\n        for ix, d in enumerate(main_input):\n            if d['type'] == 'importdistribution':\n                found = True\n                d.update(d1)\n                self.vprint(\"Updated existing importdistribution\")\n                return\n\n        # Now try to insert before the first track or write statement\n        for ix, d in enumerate(main_input):\n            if d['type'] in ('track', 'write'):\n                main_input.insert(ix, d1)          \n                self.vprint(f\"Added new importdistribution before the first {d['type']}\")\n                return\n\n\n\n        # Just append at the end. Note that a track will still be needed!\n        self.vprint(\"Nothing found, inserting at the end\")\n        main_input.append(d1)    \n</code></pre>"},{"location":"api/genesis4/#genesis.Genesis4.write_input","title":"<code>write_input(path=None, input_filename='genesis4.in')</code>","text":"<p>Write the input parameters into the file.</p>"},{"location":"api/genesis4/#genesis.Genesis4.write_input--parameters","title":"Parameters","text":"<p>input_filename : str     The file in which to write the input parameters</p> Source code in <code>genesis/version4/genesis4.py</code> <pre><code>def write_input(self, path=None, input_filename=\"genesis4.in\"):\n    \"\"\"\n    Write the input parameters into the file.\n\n    Parameters\n    ----------\n    input_filename : str\n        The file in which to write the input parameters\n    \"\"\"\n    if path is None:\n        path = self.path\n\n    assert os.path.exists(path)\n\n    filePath = os.path.join(path, input_filename)\n\n    # Write initial particles\n    self.write_initial_particles()\n\n    # Write main input file. This should come last.\n    writers.write_main_input(filePath, self.input[\"main\"])\n\n    # Write run script\n    self.get_run_script(write_to_path=True, path=path)\n</code></pre>"},{"location":"examples/genesis2/beam_file_example/","title":"Parse beam file","text":"In\u00a0[1]: Copied! <pre>from genesis.parsers import parse_beam_file\n\nimport os\n</pre> from genesis.parsers import parse_beam_file  import os In\u00a0[2]: Copied! <pre>beam = parse_beam_file('data/beam_file.txt')\nbeam\n</pre> beam = parse_beam_file('data/beam_file.txt') beam Out[2]: <pre>{'zpos': array([0.00000e+00, 1.27640e-07, 2.50220e-07, 3.78680e-07, 5.08860e-07,\n        6.31070e-07, 7.59190e-07, 8.88370e-07, 1.03209e-06, 1.16806e-06,\n        1.30948e-06]),\n 'curpeak': array([3877.54, 3779.07, 4102.97, 3548.14, 4098.73, 3721.92, 3781.47,\n        3622.15, 3421.7 , 3560.9 , 3417.84]),\n 'gamma0': array([18561.5, 18561.5, 18561.5, 18561.5, 18561.5, 18561.5, 18561.5,\n        18561.5, 18561.5, 18561.5, 18561.5]),\n 'delgam': array([3.87359, 3.91482, 3.87158, 3.99144, 3.86825, 3.51552, 3.75632,\n        3.8401 , 3.48033, 3.53304, 3.41463]),\n 'emitx': array([3.52082e-07, 3.74001e-07, 3.70076e-07, 4.06163e-07, 3.85616e-07,\n        4.25552e-07, 3.77355e-07, 3.95441e-07, 3.81738e-07, 3.98125e-07,\n        4.02012e-07]),\n 'emity': array([3.69916e-07, 3.73937e-07, 3.61763e-07, 3.93094e-07, 3.96816e-07,\n        3.91309e-07, 3.91745e-07, 3.56576e-07, 3.84286e-07, 3.79967e-07,\n        3.81965e-07]),\n 'rxbeam': array([1.55952e-05, 1.57030e-05, 1.59977e-05, 1.69573e-05, 1.66668e-05,\n        1.71053e-05, 1.61173e-05, 1.59925e-05, 1.66881e-05, 1.69303e-05,\n        1.66344e-05]),\n 'rybeam': array([2.42785e-05, 2.37501e-05, 2.54869e-05, 2.58822e-05, 2.58033e-05,\n        2.52023e-05, 2.58138e-05, 2.41442e-05, 2.47437e-05, 2.43974e-05,\n        2.47141e-05]),\n 'xbeam': array([ 1.96511e-07,  1.74440e-06,  2.63097e-07, -4.51451e-07,\n         8.00539e-08,  9.84418e-07,  1.03813e-07,  7.81866e-07,\n         8.26754e-07,  3.97480e-07,  8.05919e-07]),\n 'ybeam': array([ 1.00162e-06, -8.40405e-07,  5.24508e-07,  1.10529e-07,\n         1.28229e-06, -2.33521e-07, -1.74301e-06,  1.92027e-07,\n        -7.80745e-07, -2.27359e-06, -1.80035e-06]),\n 'pxbeam': array([ 1.44638e-03,  1.16214e-03, -7.96977e-05, -1.26631e-03,\n         9.12124e-04,  2.01356e-03,  9.09772e-04,  1.80578e-03,\n        -9.19570e-04,  1.71502e-03,  1.98139e-03]),\n 'pybeam': array([ 4.37448e-04,  1.15492e-03, -2.08997e-04, -1.52472e-03,\n        -2.10487e-03,  4.38821e-04,  3.89374e-04,  3.45168e-05,\n         1.00756e-03,  2.72220e-03,  2.52628e-03]),\n 'alphax': array([-0.562308, -0.589984, -0.612099, -0.64811 , -0.616085, -0.598018,\n        -0.624503, -0.50478 , -0.594934, -0.565338, -0.627791]),\n 'alphay': array([1.48938, 1.45762, 1.7485 , 1.68013, 1.59982, 1.59861, 1.73443,\n        1.63131, 1.61867, 1.59715, 1.59917])}</pre> In\u00a0[3]: Copied! <pre>from genesis.writers import write_beam_file\n</pre> from genesis.writers import write_beam_file In\u00a0[4]: Copied! <pre>fname = 'test_beam.txt'\n\nwrite_beam_file(fname, beam)\n\n# Parse again\nbeam2 = parse_beam_file(fname)\nbeam2\n</pre> fname = 'test_beam.txt'  write_beam_file(fname, beam)  # Parse again beam2 = parse_beam_file(fname) beam2 Out[4]: <pre>{'zpos': array([0.00000e+00, 1.27640e-07, 2.50220e-07, 3.78680e-07, 5.08860e-07,\n        6.31070e-07, 7.59190e-07, 8.88370e-07, 1.03209e-06, 1.16806e-06,\n        1.30948e-06]),\n 'curpeak': array([3877.54, 3779.07, 4102.97, 3548.14, 4098.73, 3721.92, 3781.47,\n        3622.15, 3421.7 , 3560.9 , 3417.84]),\n 'gamma0': array([18561.5, 18561.5, 18561.5, 18561.5, 18561.5, 18561.5, 18561.5,\n        18561.5, 18561.5, 18561.5, 18561.5]),\n 'delgam': array([3.87359, 3.91482, 3.87158, 3.99144, 3.86825, 3.51552, 3.75632,\n        3.8401 , 3.48033, 3.53304, 3.41463]),\n 'emitx': array([3.52082e-07, 3.74001e-07, 3.70076e-07, 4.06163e-07, 3.85616e-07,\n        4.25552e-07, 3.77355e-07, 3.95441e-07, 3.81738e-07, 3.98125e-07,\n        4.02012e-07]),\n 'emity': array([3.69916e-07, 3.73937e-07, 3.61763e-07, 3.93094e-07, 3.96816e-07,\n        3.91309e-07, 3.91745e-07, 3.56576e-07, 3.84286e-07, 3.79967e-07,\n        3.81965e-07]),\n 'rxbeam': array([1.55952e-05, 1.57030e-05, 1.59977e-05, 1.69573e-05, 1.66668e-05,\n        1.71053e-05, 1.61173e-05, 1.59925e-05, 1.66881e-05, 1.69303e-05,\n        1.66344e-05]),\n 'rybeam': array([2.42785e-05, 2.37501e-05, 2.54869e-05, 2.58822e-05, 2.58033e-05,\n        2.52023e-05, 2.58138e-05, 2.41442e-05, 2.47437e-05, 2.43974e-05,\n        2.47141e-05]),\n 'xbeam': array([ 1.96511e-07,  1.74440e-06,  2.63097e-07, -4.51451e-07,\n         8.00539e-08,  9.84418e-07,  1.03813e-07,  7.81866e-07,\n         8.26754e-07,  3.97480e-07,  8.05919e-07]),\n 'ybeam': array([ 1.00162e-06, -8.40405e-07,  5.24508e-07,  1.10529e-07,\n         1.28229e-06, -2.33521e-07, -1.74301e-06,  1.92027e-07,\n        -7.80745e-07, -2.27359e-06, -1.80035e-06]),\n 'pxbeam': array([ 1.44638e-03,  1.16214e-03, -7.96977e-05, -1.26631e-03,\n         9.12124e-04,  2.01356e-03,  9.09772e-04,  1.80578e-03,\n        -9.19570e-04,  1.71502e-03,  1.98139e-03]),\n 'pybeam': array([ 4.37448e-04,  1.15492e-03, -2.08997e-04, -1.52472e-03,\n        -2.10487e-03,  4.38821e-04,  3.89374e-04,  3.45168e-05,\n         1.00756e-03,  2.72220e-03,  2.52628e-03]),\n 'alphax': array([-0.562308, -0.589984, -0.612099, -0.64811 , -0.616085, -0.598018,\n        -0.624503, -0.50478 , -0.594934, -0.565338, -0.627791]),\n 'alphay': array([1.48938, 1.45762, 1.7485 , 1.68013, 1.59982, 1.59861, 1.73443,\n        1.63131, 1.61867, 1.59715, 1.59917])}</pre> In\u00a0[5]: Copied! <pre># Check that these are the same\nfor n in beam:\n    assert(all(beam[n] == beam2[n]))\n</pre> # Check that these are the same for n in beam:     assert(all(beam[n] == beam2[n])) In\u00a0[6]: Copied! <pre># Cleanup\nos.remove(fname)\n</pre> # Cleanup os.remove(fname)"},{"location":"examples/genesis2/beam_file_example/#parse-beam-file","title":"Parse beam file\u00b6","text":""},{"location":"examples/genesis2/beam_file_example/#write-beam-file","title":"Write beam file\u00b6","text":""},{"location":"examples/genesis2/example_interactive_plotting/","title":"Interactive plotting example","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 <p>Requires bokeh for plotting and interaction</p> In\u00a0[2]: Copied! <pre>from genesis import Genesis2, parsers, interactive\nfrom bokeh.plotting import show, output_notebook, output_file\nimport os\n</pre> from genesis import Genesis2, parsers, interactive from bokeh.plotting import show, output_notebook, output_file import os In\u00a0[3]: Copied! <pre>G = Genesis2('data/basic/genesis.in')\n\n# Turn on particle output\nG['idmppar'] = 1 # .dpa file\n# Turn on field output\nG['idmpfld'] = 1 # .dfl file\nG['npart'] = 2048\n\n# Turn on history\niskip = 10\nG['ippart'] = iskip # .par file  #Write the particle distribution to file at each IPPARTth integration step. \nG['ipradi'] = iskip  # .fld file  #Write the field distribution to file at each IPRADIth integration step.\n\ndgrid = G['dgrid']\n</pre> G = Genesis2('data/basic/genesis.in')  # Turn on particle output G['idmppar'] = 1 # .dpa file # Turn on field output G['idmpfld'] = 1 # .dfl file G['npart'] = 2048  # Turn on history iskip = 10 G['ippart'] = iskip # .par file  #Write the particle distribution to file at each IPPARTth integration step.  G['ipradi'] = iskip  # .fld file  #Write the field distribution to file at each IPRADIth integration step.  dgrid = G['dgrid'] In\u00a0[4]: Copied! <pre>G.run()\n</pre> G.run() In\u00a0[5]: Copied! <pre># May be needed to get below to work\nos.environ['BOKEH_ALLOW_WS_ORIGIN'] = 'localhost:8888'\n</pre> # May be needed to get below to work os.environ['BOKEH_ALLOW_WS_ORIGIN'] = 'localhost:8888' In\u00a0[6]: Copied! <pre>output_notebook()\ndef app(doc):\n    return interactive.genesis_interactive_field_history(doc, genesis = G)\nshow(app)\n</pre> output_notebook() def app(doc):     return interactive.genesis_interactive_field_history(doc, genesis = G) show(app) Loading BokehJS ... In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/genesis2/example_interactive_plotting/#interactive-plotting-example","title":"Interactive plotting example\u00b6","text":""},{"location":"examples/genesis2/example_parse_genesis_lattice/","title":"Parsing original Genesis lattice into a standard lattice","text":"In\u00a0[1]: Copied! <pre>from genesis import parsers, lattice\n</pre> from genesis import parsers, lattice In\u00a0[2]: Copied! <pre># Read a raw genesis-style lattice as elements and parameters\ngenesis_lat = 'data/lcls.lat'\nlat = parsers.parse_genesis_lattice(genesis_lat)\nlat.keys()\n</pre> # Read a raw genesis-style lattice as elements and parameters genesis_lat = 'data/lcls.lat' lat = parsers.parse_genesis_lattice(genesis_lat) lat.keys() Out[2]: <pre>dict_keys(['eles', 'param'])</pre> In\u00a0[3]: Copied! <pre>?lattice.standard_eles_from_eles\n</pre> ?lattice.standard_eles_from_eles <pre>Signature: lattice.standard_eles_from_eles(eles, remove_zero_strengths=True)\nDocstring:\nConverts raw ele dicts to an ordered list of elements, with absolute positions s\ns is at the end of the element\nComments are dropped.\nFile:      ~/Code/GitHub/lume-genesis/genesis/lattice.py\nType:      function\n</pre> In\u00a0[4]: Copied! <pre># Form a standard lattice from these\nlat['eles'] = lattice.standard_eles_from_eles(lat['eles'])\nlat['eles'][:10]\n</pre> # Form a standard lattice from these lat['eles'] = lattice.standard_eles_from_eles(lat['eles']) lat['eles'][:10] Out[4]: <pre>[{'type': 'AW', 'strength': 2.4749, 'L': 112.0, 's': 112.0},\n {'type': 'QF', 'strength': -17.5, 'L': 8.0, 's': 128.0},\n {'type': 'AW', 'strength': 2.4749, 'L': 112.0, 's': 240.0},\n {'type': 'QF', 'strength': 17.5, 'L': 8.0, 's': 256.0},\n {'type': 'AW', 'strength': 2.4749, 'L': 112.0, 's': 384.0},\n {'type': 'QF', 'strength': -17.5, 'L': 8.0, 's': 400.0},\n {'type': 'AW', 'strength': 2.4749, 'L': 112.0, 's': 512.0},\n {'type': 'QF', 'strength': 17.5, 'L': 8.0, 's': 528.0},\n {'type': 'AW', 'strength': 2.4749, 'L': 112.0, 's': 640.0},\n {'type': 'QF', 'strength': -17.5, 'L': 8.0, 's': 656.0}]</pre> In\u00a0[5]: Copied! <pre># Invent names for these \nlattice.create_names(lat['eles'])\nlat['eles'][:10]\n</pre> # Invent names for these  lattice.create_names(lat['eles']) lat['eles'][:10] Out[5]: <pre>[{'type': 'AW', 'strength': 2.4749, 'L': 112.0, 's': 112.0, 'name': 'AW_1'},\n {'type': 'QF', 'strength': -17.5, 'L': 8.0, 's': 128.0, 'name': 'QF_1'},\n {'type': 'AW', 'strength': 2.4749, 'L': 112.0, 's': 240.0, 'name': 'AW_2'},\n {'type': 'QF', 'strength': 17.5, 'L': 8.0, 's': 256.0, 'name': 'QF_2'},\n {'type': 'AW', 'strength': 2.4749, 'L': 112.0, 's': 384.0, 'name': 'AW_3'},\n {'type': 'QF', 'strength': -17.5, 'L': 8.0, 's': 400.0, 'name': 'QF_3'},\n {'type': 'AW', 'strength': 2.4749, 'L': 112.0, 's': 512.0, 'name': 'AW_4'},\n {'type': 'QF', 'strength': 17.5, 'L': 8.0, 's': 528.0, 'name': 'QF_4'},\n {'type': 'AW', 'strength': 2.4749, 'L': 112.0, 's': 640.0, 'name': 'AW_5'},\n {'type': 'QF', 'strength': -17.5, 'L': 8.0, 's': 656.0, 'name': 'QF_5'}]</pre> In\u00a0[6]: Copied! <pre># Form original Genesis lattice\nlines = lattice.genesis_lattice_from_standard_lattice(lat)\nprint('\\n'.join(lines))\n</pre> # Form original Genesis lattice lines = lattice.genesis_lattice_from_standard_lattice(lat) print('\\n'.join(lines)) <pre>? VERSION = 1\n? UNITLENGTH = 0.03 # meters\n\n#------------\n# QF\nQF -17.5 8.0 120.0\nQF 0 120.0 0.0\nQF 17.5 8.0 0.0\nQF 0 136.0 0.0\nQF -17.5 8.0 0.0\nQF 0 120.0 0.0\nQF 17.5 8.0 0.0\nQF 0 120.0 0.0\nQF -17.5 8.0 0.0\nQF 0 136.0 0.0\nQF 17.5 8.0 0.0\nQF 0 120.0 0.0\nQF -17.5 8.0 0.0\nQF 0 120.0 0.0\nQF 17.5 8.0 0.0\nQF 0 136.0 0.0\nQF -17.5 8.0 0.0\nQF 0 120.0 0.0\nQF 17.5 8.0 0.0\nQF 0 120.0 0.0\nQF -17.5 8.0 0.0\nQF 0 136.0 0.0\nQF 17.5 8.0 0.0\nQF 0 120.0 0.0\nQF -17.5 8.0 0.0\nQF 0 120.0 0.0\nQF 17.5 8.0 0.0\nQF 0 136.0 0.0\nQF -17.5 8.0 0.0\nQF 0 120.0 0.0\nQF 17.5 8.0 0.0\nQF 0 120.0 0.0\nQF -17.5 8.0 0.0\nQF 0 136.0 0.0\nQF 17.5 8.0 0.0\nQF 0 120.0 0.0\nQF -17.5 8.0 0.0\nQF 0 120.0 0.0\nQF 17.5 8.0 0.0\nQF 0 136.0 0.0\nQF -17.5 8.0 0.0\nQF 0 120.0 0.0\nQF 17.5 8.0 0.0\nQF 0 120.0 0.0\nQF -17.5 8.0 0.0\nQF 0 136.0 0.0\nQF 17.5 8.0 0.0\nQF 0 120.0 0.0\nQF -17.5 8.0 0.0\nQF 0 120.0 0.0\nQF 17.5 8.0 0.0\nQF 0 136.0 0.0\nQF -17.5 8.0 0.0\nQF 0 120.0 0.0\nQF 17.5 8.0 0.0\nQF 0 120.0 0.0\nQF -17.5 8.0 0.0\nQF 0 136.0 0.0\nQF 17.5 8.0 0.0\nQF 0 120.0 0.0\nQF -17.5 8.0 0.0\nQF 0 120.0 0.0\nQF 17.5 8.0 0.0\nQF 0 136.0 0.0\nQF -17.5 8.0 0.0\nQF 0 120.0 0.0\nQF 17.5 8.0 0.0\nQF 0 120.0 0.0\nQF -17.5 8.0 0.0\nQF 0 136.0 0.0\nQF 17.5 8.0 0.0\nQF 0 120.0 0.0\nQF -17.5 8.0 0.0\nQF 0 120.0 0.0\nQF 17.5 8.0 0.0\nQF 0 136.0 0.0\nQF -17.5 8.0 0.0\nQF 0 120.0 0.0\nQF 17.5 8.0 0.0\nQF 0 120.0 0.0\nQF -17.5 8.0 0.0\nQF 0 136.0 0.0\nQF 17.5 8.0 0.0\n\n#------------\n# AW\nAW 2.4749 112.0 0.0\nAW 0 16.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 32.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 16.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 16.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 32.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 16.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 16.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 32.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 16.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 16.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 32.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 16.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 16.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 32.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 16.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 16.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 32.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 16.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 16.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 32.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 16.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 16.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 32.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 16.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 16.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 32.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 16.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 16.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 32.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 16.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 16.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 32.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 16.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 16.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 32.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 16.0 0.0\nAW 2.4749 112.0 0.0\nAW 0 688.0 0.0\n</pre>"},{"location":"examples/genesis2/example_parse_genesis_lattice/#parsing-original-genesis-lattice-into-a-standard-lattice","title":"Parsing original Genesis lattice into a standard lattice\u00b6","text":""},{"location":"examples/genesis2/example_parsing_genesis_field/","title":"Parsing Genesis2 Field data","text":"In\u00a0[1]: Copied! <pre>from genesis import Genesis2, parsers\n\nimport numpy as np\nimport os\n</pre> from genesis import Genesis2, parsers  import numpy as np import os In\u00a0[2]: Copied! <pre># Make some dfl, fld data\nG = Genesis2('data/basic/genesis.in')\n# Turn on field output\nG['idmpfld'] = 1\n# Turn on particle output\n#G['idmppar'] = 1\nG['npart'] = 2048\n\n# Turn on history\n#G['ippart'] = 10\nG['ipradi'] = 10\n\nG.run()\n</pre> # Make some dfl, fld data G = Genesis2('data/basic/genesis.in') # Turn on field output G['idmpfld'] = 1 # Turn on particle output #G['idmppar'] = 1 G['npart'] = 2048  # Turn on history #G['ippart'] = 10 G['ipradi'] = 10  G.run() In\u00a0[3]: Copied! <pre># These are the files written\n!ls {G.path}\n</pre> # These are the files written !ls {G.path} <pre>genesis.in          genesis.out.dfl     genesis_lattice.in  run\ngenesis.out         genesis.out.fld     genesis_lattice.out\n</pre> In\u00a0[4]: Copied! <pre># Change this\n#test_dir = 'path/to/your/output'\ntest_dir = G.path\n\n\nout_fname = os.path.join(test_dir,'genesis.out')\ndfl_fname = os.path.join(test_dir,'genesis.out.dfl')\nfld_fname = os.path.join(test_dir,'genesis.out.fld')\n\n# Get parameters from .out file\nodat = parsers.parse_genesis_out(out_fname)\nparams = odat['param']\n\n\nmy_ncar = params['ncar']\nmy_dgrid = params['dgrid']\n\nmy_nz = 1\n</pre> # Change this #test_dir = 'path/to/your/output' test_dir = G.path   out_fname = os.path.join(test_dir,'genesis.out') dfl_fname = os.path.join(test_dir,'genesis.out.dfl') fld_fname = os.path.join(test_dir,'genesis.out.fld')  # Get parameters from .out file odat = parsers.parse_genesis_out(out_fname) params = odat['param']   my_ncar = params['ncar'] my_dgrid = params['dgrid']  my_nz = 1 In\u00a0[5]: Copied! <pre>my_dfl = parsers.parse_genesis_dfl(dfl_fname, nx=my_ncar)\nmy_dfl\n</pre>  my_dfl = parsers.parse_genesis_dfl(dfl_fname, nx=my_ncar) my_dfl Out[5]: <pre>array([[[ -74.06406378 -41.1522182j ],\n        [ -70.69169495 +35.2485532j ],\n        [ -34.56735661 +36.64746991j],\n        ...,\n        [ -99.99222671 +64.3232483j ],\n        [-180.44653972 +53.09925555j],\n        [-123.59034512 +43.32841857j]],\n\n       [[ -77.64583038 +25.68134794j],\n        [ -59.10378581 +75.07862004j],\n        [ -40.19541166 +17.38747437j],\n        ...,\n        [-137.86895776+112.39814644j],\n        [-191.09639422+125.43913825j],\n        [-166.80208003 +94.81443235j]],\n\n       [[ -40.76724116 +53.02386818j],\n        [ -67.79229975 +56.51067843j],\n        [ -62.5600458   -5.4709485j ],\n        ...,\n        [-120.71071331 +36.02497355j],\n        [-153.65484851 +46.93304811j],\n        [ -88.03670552 +71.78352387j]],\n\n       ...,\n\n       [[ -51.07276226 +34.42936827j],\n        [-136.12517482 +55.07515669j],\n        [ -91.02017614+108.58759022j],\n        ...,\n        [ -47.22803284 -11.61034293j],\n        [ -35.12138549 +63.21364087j],\n        [ -26.36195997 +79.72819145j]],\n\n       [[ -70.93536837+111.48537387j],\n        [-130.30098574 +92.12084929j],\n        [-105.06016481 +98.41073674j],\n        ...,\n        [ -29.67752509 +33.78370159j],\n        [ -59.15841384 +91.4020774j ],\n        [ -90.13662749 +37.89501734j]],\n\n       [[ -73.10241872+118.56703001j],\n        [-115.73348084 +51.61442684j],\n        [ -64.59190724 +19.6376805j ],\n        ...,\n        [ -19.63116972 +72.61489422j],\n        [ -53.33140133 +67.53949677j],\n        [ -74.07953578 -32.60556104j]]])</pre> In\u00a0[6]: Copied! <pre>my_fld = parsers.parse_genesis_fld(fld_fname, my_ncar, my_nz)\nmy_fld[-1]\n</pre> my_fld = parsers.parse_genesis_fld(fld_fname, my_ncar, my_nz) my_fld[-1] Out[6]: <pre>array([[[ 8.89456540e-25+0.00000000e+00j,\n          2.74655617e-25-1.21938798e-26j,\n          1.91891710e-25+1.38059784e-25j, ...,\n          7.72723934e+01+2.16850325e+01j,\n         -2.44469626e+01-5.50954091e+01j,\n         -7.31024187e+01+1.18567030e+02j]],\n\n       [[ 1.30023561e-24+0.00000000e+00j,\n          6.44034233e-25-3.81664255e-26j,\n          4.31421869e-25+2.96739826e-25j, ...,\n          4.76686205e+01-3.84748082e+01j,\n         -5.92580270e+01-1.17354941e+02j,\n         -1.15733481e+02+5.16144268e+01j]],\n\n       [[ 1.89493756e-24+0.00000000e+00j,\n          1.12545763e-24+1.32160584e-25j,\n          7.18423368e-25+5.51242570e-25j, ...,\n          3.24052986e+01-1.52505216e+01j,\n         -4.38651049e+01-8.32682685e+01j,\n         -6.45919072e+01+1.96376805e+01j]],\n\n       ...,\n\n       [[ 1.89493756e-24+0.00000000e+00j,\n          1.12545763e-24+1.32160584e-25j,\n          7.18423368e-25+5.51242570e-25j, ...,\n          1.61117374e+01-8.06376373e+00j,\n         -1.94799456e+01-1.42050383e+01j,\n         -1.96311697e+01+7.26148942e+01j]],\n\n       [[ 1.30023561e-24+0.00000000e+00j,\n          6.44034233e-25-3.81664255e-26j,\n          4.31421869e-25+2.96739826e-25j, ...,\n          2.45028025e+01+5.48709159e+01j,\n         -2.80265435e+00-3.68766218e+01j,\n         -5.33314013e+01+6.75394968e+01j]],\n\n       [[ 8.89456540e-25+0.00000000e+00j,\n          2.74655617e-25-1.21938798e-26j,\n          1.91891710e-25+1.38059784e-25j, ...,\n          1.61820281e+00+1.32986281e+01j,\n         -1.54807385e+01-7.92795417e+01j,\n         -7.40795358e+01-3.26055610e+01j]]])</pre> In\u00a0[7]: Copied! <pre>import matplotlib.pyplot as plt\n</pre> import matplotlib.pyplot as plt In\u00a0[8]: Copied! <pre># Field phase at end, slice 0\ndef plot_field(dat, dgrid):\n    ndat = np.angle(dat)\n    plt.imshow(ndat, extent = [1000*dgrid*i for i in [-1,1,-1,1]])\n    plt.xlabel('x (mm)')\n    plt.ylabel('y (mm)')\n    plt.show()\nplot_field(my_dfl[:, :, 0], my_dgrid )\n</pre> # Field phase at end, slice 0 def plot_field(dat, dgrid):     ndat = np.angle(dat)     plt.imshow(ndat, extent = [1000*dgrid*i for i in [-1,1,-1,1]])     plt.xlabel('x (mm)')     plt.ylabel('y (mm)')     plt.show() plot_field(my_dfl[:, :, 0], my_dgrid )     In\u00a0[9]: Copied! <pre># Field phrase from history file, slice 0\nplot_field(my_fld[:, :, 0, -1], my_dgrid )\n</pre> # Field phrase from history file, slice 0 plot_field(my_fld[:, :, 0, -1], my_dgrid )"},{"location":"examples/genesis2/example_parsing_genesis_field/#parsing-genesis2-field-data","title":"Parsing Genesis2 Field data\u00b6","text":""},{"location":"examples/genesis2/example_parsing_genesis_field/#plot","title":"Plot\u00b6","text":""},{"location":"examples/genesis2/example_parsing_genesis_out/","title":"Plotting","text":"In\u00a0[1]: Copied! <pre>from genesis import parsers\n</pre> from genesis import parsers In\u00a0[2]: Copied! <pre>import matplotlib.pyplot as plt\n%matplotlib inline\nplt.rcParams['figure.figsize'] = [8,8]\n%config InlineBackend.figure_format = 'retina'\n</pre> import matplotlib.pyplot as plt %matplotlib inline plt.rcParams['figure.figsize'] = [8,8] %config InlineBackend.figure_format = 'retina' In\u00a0[3]: Copied! <pre>fname = 'data/mod_3.out'\n\n# This parses the entier outfile\ngout = parsers.parse_genesis_out(fname)\n\n# This is a dict of:\ngout.keys()\n</pre> fname = 'data/mod_3.out'  # This parses the entier outfile gout = parsers.parse_genesis_out(fname)  # This is a dict of: gout.keys() Out[3]: <pre>dict_keys(['param', 'data'])</pre> In\u00a0[4]: Copied! <pre># param is the readback of the basic paramters:\nlist(gout['param'])[0:10]\n</pre> # param is the readback of the basic paramters: list(gout['param'])[0:10] Out[4]: <pre>['aw0',\n 'xkx',\n 'xky',\n 'wcoefz(1)',\n 'wcoefz(2)',\n 'wcoefz(3)',\n 'xlamd',\n 'fbess0',\n 'delaw',\n 'iertyp']</pre> In\u00a0[5]: Copied! <pre># Data contains the lattice readback arrays, slice data, and possibly field and particle data\ndata = gout['data']\nfor k in data:\n    print(k, data[k].shape)\n</pre> # Data contains the lattice readback arrays, slice data, and possibly field and particle data data = gout['data'] for k in data:     print(k, data[k].shape) <pre>z (2,)\naw (2,)\nqfld (2,)\nindex (1,)\ncurrent (1,)\npower (1, 2)\np_mid (1, 2)\nphi_mid (1, 2)\nr_size (1, 2)\nenergy (1, 2)\nbunching (1, 2)\nxrms (1, 2)\nyrms (1, 2)\nerror (1, 2)\ne-spread (1, 2)\n</pre> In\u00a0[6]: Copied! <pre>z = data['z']\n\nfor i in range(len(data['index'])):\n    \n    power = data['power'][i, :]\n    \n    plt.plot(z, power)\n</pre>  z = data['z']  for i in range(len(data['index'])):          power = data['power'][i, :]          plt.plot(z, power)  In\u00a0[7]: Copied! <pre>x1 = gout['data']['z']\nx2 = gout['data']['z']\n\ny1 = gout['data']['aw']\ny2 = gout['data']['qfld']\n\nplt.subplot(2, 1, 1)\nplt.plot(x1, y1, 'o-')\nplt.title('Lattice')\nplt.ylabel('qw')\n\nplt.subplot(2, 1, 2)\nplt.plot(x2, y2, '.-')\nplt.xlabel('z (m)')\nplt.ylabel('qfld')\n\nplt.show()\n</pre> x1 = gout['data']['z'] x2 = gout['data']['z']  y1 = gout['data']['aw'] y2 = gout['data']['qfld']  plt.subplot(2, 1, 1) plt.plot(x1, y1, 'o-') plt.title('Lattice') plt.ylabel('qw')  plt.subplot(2, 1, 2) plt.plot(x2, y2, '.-') plt.xlabel('z (m)') plt.ylabel('qfld')  plt.show()"},{"location":"examples/genesis2/example_parsing_genesis_out/#plotting","title":"Plotting\u00b6","text":""},{"location":"examples/genesis2/genesis2_example/","title":"Simple LUME-Genesis example for Genesis 1.3 Version 2 (Genesis2)","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>from genesis import Genesis2\n\n# Make genesis object with some input file\nG = Genesis2('data/basic/genesis.in', verbose=True)\n</pre> from genesis import Genesis2  # Make genesis object with some input file G = Genesis2('data/basic/genesis.in', verbose=True) <pre>Configured to run in: /var/folders/wj/lfgr01993dx79p9cm_skykbw0000gn/T/tmp_xuchipn\n</pre> In\u00a0[3]: Copied! <pre># Turn on field output\nG['idmpfld'] = 1\n# Turn on particle output\nG['idmppar'] = 1\nG['npart'] = 2048\n\n# Turn on history\nG['ippart'] = 10\nG['ipradi'] = 0\n</pre> # Turn on field output G['idmpfld'] = 1 # Turn on particle output G['idmppar'] = 1 G['npart'] = 2048  # Turn on history G['ippart'] = 10 G['ipradi'] = 0 In\u00a0[4]: Copied! <pre># Run genesis with default lattice \nG.run()\n</pre> # Run genesis with default lattice  G.run() <pre>Running genesis in /var/folders/wj/lfgr01993dx79p9cm_skykbw0000gn/T/tmp_xuchipn\nLattice written: /var/folders/wj/lfgr01993dx79p9cm_skykbw0000gn/T/tmp_xuchipn/genesis_lattice.in\n-------------------------------\nGenesis 1.3 has begun execution\n(Version 2.6 Unix)\n\nPlease enter input file name \n***  Warning: Size of particle file [Mbytes]:  14     \nSlice     1: Simulation  10% completed.\nSlice     1: Simulation  20% completed.\nSlice     1: Simulation  30% completed.\nSlice     1: Simulation  40% completed.\nSlice     1: Simulation  50% completed.\nSlice     1: Simulation  60% completed.\nSlice     1: Simulation  70% completed.\nSlice     1: Simulation  80% completed.\nSlice     1: Simulation  90% completed.\nSlice     1: Simulation 100% completed.\n***  writing history record for slice     1\n***  closing files\n\nGenesis run has finished\n------------------------\n</pre> In\u00a0[5]: Copied! <pre>G.output['data'].keys()\n</pre> G.output['data'].keys() Out[5]: <pre>dict_keys(['z', 'aw', 'qfld', 'index', 'current', 'power', 'increment', 'p_mid', 'phi_mid', 'r_size', 'energy', 'bunching', 'xrms', 'yrms', 'error', '&lt;x&gt;', '&lt;y&gt;', 'e-spread', 'far_field', 'dfl', 'dpa', 'par'])</pre> In\u00a0[6]: Copied! <pre>G.write_wavefront()\n</pre> G.write_wavefront() <pre>Writing wavefront (dfl data) to file genesis_wavefront_ac527a9a7ba0aa9d23cc0977b9eb4d59.h5\n</pre> Out[6]: <pre>'genesis_wavefront_ac527a9a7ba0aa9d23cc0977b9eb4d59.h5'</pre> In\u00a0[7]: Copied! <pre>G.archive()\n</pre> G.archive() <pre>Archiving to file genesis_ac527a9a7ba0aa9d23cc0977b9eb4d59.h5\nArchived output: param, data\n</pre> Out[7]: <pre>'genesis_ac527a9a7ba0aa9d23cc0977b9eb4d59.h5'</pre> In\u00a0[8]: Copied! <pre># This is the working path\nG.path\n</pre> # This is the working path G.path Out[8]: <pre>'/var/folders/wj/lfgr01993dx79p9cm_skykbw0000gn/T/tmp_xuchipn'</pre> In\u00a0[9]: Copied! <pre># Contents of this\n!ls -ahl {G.path}\n</pre> # Contents of this !ls -ahl {G.path} <pre>total 34232\ndrwx------   10 chrisonian  staff   320B Jul  5 21:23 .\ndrwx------@ 203 chrisonian  staff   6.3K Jul  5 21:23 ..\n-rw-r--r--    1 chrisonian  staff   2.2K Jul  5 21:23 genesis.in\n-rw-r--r--    1 chrisonian  staff   412K Jul  5 21:23 genesis.out\n-rw-r--r--    1 chrisonian  staff   984K Jul  5 21:23 genesis.out.dfl\n-rw-r--r--    1 chrisonian  staff    96K Jul  5 21:23 genesis.out.dpa\n-rw-r--r--    1 chrisonian  staff    15M Jul  5 21:23 genesis.out.par\n-rw-r--r--    1 chrisonian  staff   1.3K Jul  5 21:23 genesis_lattice.in\n-rw-r--r--    1 chrisonian  staff   1.3K Jul  5 21:23 genesis_lattice.out\n-rw-r--r--    1 chrisonian  staff    68B Jul  5 21:23 run\n</pre> In\u00a0[10]: Copied! <pre># Get a hash of the input\nG.fingerprint()\n</pre> # Get a hash of the input G.fingerprint() Out[10]: <pre>'ac527a9a7ba0aa9d23cc0977b9eb4d59'</pre> In\u00a0[11]: Copied! <pre># Lattice parameters\nG.lattice['param']\n</pre> # Lattice parameters G.lattice['param'] Out[11]: <pre>{'version': 1, 'unitlength': 0.03}</pre> In\u00a0[12]: Copied! <pre># Get a list of z from the output\nG.output.keys()\n</pre> # Get a list of z from the output G.output.keys() Out[12]: <pre>dict_keys(['param', 'data'])</pre> In\u00a0[13]: Copied! <pre># These are the available data\nG.output['data'].keys()\n</pre> # These are the available data G.output['data'].keys() Out[13]: <pre>dict_keys(['z', 'aw', 'qfld', 'index', 'current', 'power', 'increment', 'p_mid', 'phi_mid', 'r_size', 'energy', 'bunching', 'xrms', 'yrms', 'error', '&lt;x&gt;', '&lt;y&gt;', 'e-spread', 'far_field', 'dfl', 'dpa', 'par'])</pre> In\u00a0[14]: Copied! <pre>zlist = G.output['data']['z']\nzlist.shape\n</pre> zlist = G.output['data']['z'] zlist.shape Out[14]: <pre>(1561,)</pre> In\u00a0[15]: Copied! <pre># Get power. This is a 2d array of: slice, z\npower = G.output['data']['power']\npower.shape\n</pre> # Get power. This is a 2d array of: slice, z power = G.output['data']['power'] power.shape Out[15]: <pre>(1, 1561)</pre> In\u00a0[16]: Copied! <pre># Simpler plot\n\nimport matplotlib.pyplot as plt\n%config InlineBackend.figure_format = 'retina'\n\nplt.xlabel('Z (m)')\nplt.ylabel('Power (GW)')\n\nplt.plot(zlist, power[0]/1e9)\n</pre> # Simpler plot  import matplotlib.pyplot as plt %config InlineBackend.figure_format = 'retina'  plt.xlabel('Z (m)') plt.ylabel('Power (GW)')  plt.plot(zlist, power[0]/1e9)  Out[16]: <pre>[&lt;matplotlib.lines.Line2D at 0x125eab580&gt;]</pre> In\u00a0[17]: Copied! <pre>afile = G.archive()\n</pre> afile = G.archive() <pre>Archiving to file genesis_ac527a9a7ba0aa9d23cc0977b9eb4d59.h5\nArchived output: param, data\n</pre> In\u00a0[18]: Copied! <pre>G2 = Genesis2()\nG2.load_archive(afile)\n</pre> G2 = Genesis2() G2.load_archive(afile) In\u00a0[19]: Copied! <pre># Check that fingetprints (hash on input) are the same\nG.fingerprint() == G2.fingerprint()\n</pre> # Check that fingetprints (hash on input) are the same G.fingerprint() == G2.fingerprint() Out[19]: <pre>True</pre> In\u00a0[20]: Copied! <pre>import numpy as np\n\n\n# Check that all output data are the same\nfor k in G.output['data']:\n    print(k, np.all(G.output['data'][k]==G2.output['data'][k]))\n</pre> import numpy as np   # Check that all output data are the same for k in G.output['data']:     print(k, np.all(G.output['data'][k]==G2.output['data'][k])) <pre>z True\naw True\nqfld True\nindex True\ncurrent True\npower True\nincrement True\np_mid True\nphi_mid True\nr_size True\nenergy True\nbunching True\nxrms True\nyrms True\nerror True\n&lt;x&gt; True\n&lt;y&gt; True\ne-spread True\nfar_field True\ndfl True\ndpa True\npar True\n</pre> In\u00a0[21]: Copied! <pre>wfile = G.write_wavefront()\n</pre> wfile = G.write_wavefront() <pre>Writing wavefront (dfl data) to file genesis_wavefront_ac527a9a7ba0aa9d23cc0977b9eb4d59.h5\n</pre> In\u00a0[22]: Copied! <pre># Read back\nimport h5py\nwith h5py.File(wfile, 'r') as h5:\n    component = h5['data/000000/meshes/electricField/x']\n    E = component[:]\n    attrs = dict(component.attrs)\n\n# This is the conversion factor to the proper SI unit for electric field    \nattrs\n</pre> # Read back import h5py with h5py.File(wfile, 'r') as h5:     component = h5['data/000000/meshes/electricField/x']     E = component[:]     attrs = dict(component.attrs)  # This is the conversion factor to the proper SI unit for electric field     attrs Out[22]: <pre>{'unitSI': 4574872.878997542, 'unitSymbol': 'V/m'}</pre> In\u00a0[23]: Copied! <pre># Check the shapes\nE.shape\n</pre> # Check the shapes E.shape Out[23]: <pre>(251, 251, 1)</pre> In\u00a0[24]: Copied! <pre># Plot the phase\n%matplotlib inline\nimport matplotlib.pyplot as plt\nplt.rcParams['figure.figsize'] = [8,8]\n\n\nndat = np.angle(E[:,:,0]) # Complex angle\nplt.imshow(ndat, extent = [1e3*G['dgrid']*i for i in [-1,1,-1,1]])\nplt.xlabel('x (mm)')\nplt.ylabel('y (mm)')\nplt.show()\n</pre> # Plot the phase %matplotlib inline import matplotlib.pyplot as plt plt.rcParams['figure.figsize'] = [8,8]   ndat = np.angle(E[:,:,0]) # Complex angle plt.imshow(ndat, extent = [1e3*G['dgrid']*i for i in [-1,1,-1,1]]) plt.xlabel('x (mm)') plt.ylabel('y (mm)') plt.show() In\u00a0[25]: Copied! <pre>import numpy as np\nimport os\nimport time\n</pre> import numpy as np import os import time In\u00a0[26]: Copied! <pre># gamma, phase, x, y, px/mc, py/mc\nb = G.output['data']['par']\n</pre> # gamma, phase, x, y, px/mc, py/mc b = G.output['data']['par'] In\u00a0[27]: Copied! <pre>p = b[-1]\nplt.hist2d(p[1]% (2*np.pi), 0.511*p[0], bins=[100,100], cmap=plt.get_cmap('plasma'))\nplt.xlabel('phase')\nplt.ylabel('energy (MeV)')\n#plt.savefig('frame.png')\nplt.show()\n</pre> p = b[-1] plt.hist2d(p[1]% (2*np.pi), 0.511*p[0], bins=[100,100], cmap=plt.get_cmap('plasma')) plt.xlabel('phase') plt.ylabel('energy (MeV)') #plt.savefig('frame.png') plt.show() In\u00a0[28]: Copied! <pre>def frame(i, ):\n    p = b[i]\n    plt.hist2d(p[1]% (2*np.pi), 0.511*p[0], bins=[200,200], cmap=plt.get_cmap('plasma'))\n    plt.xlabel('phase')\n    plt.ylabel('energy (MeV)')\n   # plt.savefig('frame_'+str(i)+'.png')\n    \nframe(100)\n</pre> def frame(i, ):     p = b[i]     plt.hist2d(p[1]% (2*np.pi), 0.511*p[0], bins=[200,200], cmap=plt.get_cmap('plasma'))     plt.xlabel('phase')     plt.ylabel('energy (MeV)')    # plt.savefig('frame_'+str(i)+'.png')      frame(100) In\u00a0[29]: Copied! <pre># Make frames\n#for i in range(nbunch):\n#    frame(i);\n</pre> # Make frames #for i in range(nbunch): #    frame(i); In\u00a0[30]: Copied! <pre># Make movie\n#!ffmpeg -framerate 10 -i frame_%d.png -c:v libx264 -c:a libfdk_aac output.mp4\n</pre> # Make movie #!ffmpeg -framerate 10 -i frame_%d.png -c:v libx264 -c:a libfdk_aac output.mp4 In\u00a0[31]: Copied! <pre>P = G.final_particles()\nP\n</pre> P = G.final_particles() P Out[31]: <pre>&lt;ParticleGroup with 2048 particles at 0x125f27160&gt;</pre> In\u00a0[32]: Copied! <pre>P.plot('t', 'energy')\n</pre> P.plot('t', 'energy') In\u00a0[33]: Copied! <pre>os.remove(afile)\nos.remove(wfile)\n</pre> os.remove(afile) os.remove(wfile)"},{"location":"examples/genesis2/genesis2_example/#simple-lume-genesis-example-for-genesis-13-version-2-genesis2","title":"Simple LUME-Genesis example for Genesis 1.3 Version 2 (Genesis2)\u00b6","text":""},{"location":"examples/genesis2/genesis2_example/#archiving","title":"Archiving\u00b6","text":""},{"location":"examples/genesis2/genesis2_example/#wavefront-dfl-in-openpmd-wavefront-format","title":"Wavefront (dfl) in openPMD-wavefront format\u00b6","text":"<p>This will write the loaded <code>dfl</code> data to a proper openPMD-wavefront file</p>"},{"location":"examples/genesis2/genesis2_example/#raw-particle-history","title":"Raw particle history\u00b6","text":""},{"location":"examples/genesis2/genesis2_example/#final-particles","title":"Final particles\u00b6","text":"<p>If a final particle (.dpa file) data was made, this will process the internal arrays into a high-level ParticleGroup object.</p>"},{"location":"examples/genesis2/genesis2_example/#cleanup","title":"Cleanup\u00b6","text":""},{"location":"examples/genesis4/fodo_scan/","title":"Genesis4 FODO Scan","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>from genesis.version4 import Genesis4\nfrom lume.tools import full_path\nimport os\nfrom copy import deepcopy\nimport numpy as np\nimport matplotlib.pyplot as plt\n%config InlineBackend.figure_format = 'retina'\n</pre> from genesis.version4 import Genesis4 from lume.tools import full_path import os from copy import deepcopy import numpy as np import matplotlib.pyplot as plt %config InlineBackend.figure_format = 'retina' In\u00a0[3]: Copied! <pre>LATFILE = 'data/genesis4_fodo.lat'\n\ndef make_lat(k1=2, latfile=LATFILE):\n    lat = f\"\"\"\nD1: DRIFT = {{ l = 0.445}};\nD2: DRIFT = {{ l = 0.24}};\nQF: QUADRUPOLE = {{ l = 0.080000, k1= {k1} }};\nQD: QUADRUPOLE = {{ l = 0.080000, k1= {-k1} }};\n\nUND: UNDULATOR = {{ lambdau=0.015000,nwig=266,aw=0.84853}};\n\nFODO: LINE= {{UND,D1,QF,D2,UND,D1,QD,D2}};\n\nARAMIS: LINE= {{13*FODO}};\n    \"\"\"\n    with open(latfile, 'w') as f:\n        f.write(lat)\n        \n    return full_path(latfile)\n    \nmake_lat()\n!cat {LATFILE}\n</pre> LATFILE = 'data/genesis4_fodo.lat'  def make_lat(k1=2, latfile=LATFILE):     lat = f\"\"\" D1: DRIFT = {{ l = 0.445}}; D2: DRIFT = {{ l = 0.24}}; QF: QUADRUPOLE = {{ l = 0.080000, k1= {k1} }}; QD: QUADRUPOLE = {{ l = 0.080000, k1= {-k1} }};  UND: UNDULATOR = {{ lambdau=0.015000,nwig=266,aw=0.84853}};  FODO: LINE= {{UND,D1,QF,D2,UND,D1,QD,D2}};  ARAMIS: LINE= {{13*FODO}};     \"\"\"     with open(latfile, 'w') as f:         f.write(lat)              return full_path(latfile)      make_lat() !cat {LATFILE} <pre>\nD1: DRIFT = { l = 0.445};\nD2: DRIFT = { l = 0.24};\nQF: QUADRUPOLE = { l = 0.080000, k1= 2 };\nQD: QUADRUPOLE = { l = 0.080000, k1= -2 };\n\nUND: UNDULATOR = { lambdau=0.015000,nwig=266,aw=0.84853};\n\nFODO: LINE= {UND,D1,QF,D2,UND,D1,QD,D2};\n\nARAMIS: LINE= {13*FODO};\n    </pre> In\u00a0[4]: Copied! <pre>FILE = 'data/aramis/genesis4.in'\nG = Genesis4()\nINPUT0 = {'main': [{'type': 'setup',\n   'rootname': 'Benchmark',\n   'lattice': make_lat(k1=2),\n   'beamline': 'ARAMIS',\n   'lambda0': 1e-10,\n   'gamma0': 11357.82,\n   'delz': 0.045,\n   'shotnoise': 0,\n   'beam_global_stat': True,\n   'field_global_stat': True},\n  {'type': 'lattice', 'zmatch': 9.5},\n  {'type': 'field',\n   'power': 5000,\n   'dgrid': 0.0002,\n   'ngrid': 255,\n   'waist_size': 3e-05},\n  {'type': 'beam', 'current': 3000, 'delgam': 1, 'ex': 4e-07, 'ey': 4e-07},\n  {'type': 'track', 'zstop': 123.5}]}\nG.input = deepcopy(INPUT0)\n</pre> FILE = 'data/aramis/genesis4.in' G = Genesis4() INPUT0 = {'main': [{'type': 'setup',    'rootname': 'Benchmark',    'lattice': make_lat(k1=2),    'beamline': 'ARAMIS',    'lambda0': 1e-10,    'gamma0': 11357.82,    'delz': 0.045,    'shotnoise': 0,    'beam_global_stat': True,    'field_global_stat': True},   {'type': 'lattice', 'zmatch': 9.5},   {'type': 'field',    'power': 5000,    'dgrid': 0.0002,    'ngrid': 255,    'waist_size': 3e-05},   {'type': 'beam', 'current': 3000, 'delgam': 1, 'ex': 4e-07, 'ey': 4e-07},   {'type': 'track', 'zstop': 123.5}]} G.input = deepcopy(INPUT0) In\u00a0[5]: Copied! <pre>%%time\nG.nproc=8\nG.run()\n</pre> %%time G.nproc=8 G.run() <pre>CPU times: user 9.21 ms, sys: 5.48 ms, total: 14.7 ms\nWall time: 12.5 s\n</pre> In\u00a0[6]: Copied! <pre>G.plot('power', yscale='log', y2=['beam_xsize', 'beam_ysize'], ylim2=(0,50e-6))\n</pre> G.plot('power', yscale='log', y2=['beam_xsize', 'beam_ysize'], ylim2=(0,50e-6)) In\u00a0[7]: Copied! <pre>%%time\ndef run1(k):\n    make_lat(k)\n    G = Genesis4()\n    G.input = deepcopy(INPUT0)\n    G.input['main'][0]['lattice'] = full_path(LATFILE)\n    G.input['main'][-1]['zstop'] = 20  \n    G.nproc = 8\n    G.run()\n    return G\n\nG2=run1(4)\n</pre> %%time def run1(k):     make_lat(k)     G = Genesis4()     G.input = deepcopy(INPUT0)     G.input['main'][0]['lattice'] = full_path(LATFILE)     G.input['main'][-1]['zstop'] = 20       G.nproc = 8     G.run()     return G  G2=run1(4) <pre>CPU times: user 8.89 ms, sys: 6 ms, total: 14.9 ms\nWall time: 2.11 s\n</pre> In\u00a0[8]: Copied! <pre>G2.plot('power', yscale='log', y2=['beam_xsize', 'beam_ysize'], ylim2=(0, 50e-6))\n</pre> G2.plot('power', yscale='log', y2=['beam_xsize', 'beam_ysize'], ylim2=(0, 50e-6)) In\u00a0[9]: Copied! <pre>%%time\nklist = np.linspace(1, 3, 10)\nGlist = [run1(k) for k in klist]\n</pre> %%time klist = np.linspace(1, 3, 10) Glist = [run1(k) for k in klist] <pre>CPU times: user 89.1 ms, sys: 49 ms, total: 138 ms\nWall time: 21.7 s\n</pre> In\u00a0[10]: Copied! <pre>fig, ax = plt.subplots()\nfor k, g in zip(klist, Glist):\n    x = g.stat('zplot')\n    y = g.stat('power')\n    ax.plot(x, y/1e6, label = f'{k:0.1f}')\nax.set_yscale('log')\nax.set_xlabel(r'$z$ (m)')\nax.set_ylabel('power (MW)')\nplt.legend(title = r'$k$ (1/m$^2$)')\n</pre> fig, ax = plt.subplots() for k, g in zip(klist, Glist):     x = g.stat('zplot')     y = g.stat('power')     ax.plot(x, y/1e6, label = f'{k:0.1f}') ax.set_yscale('log') ax.set_xlabel(r'$z$ (m)') ax.set_ylabel('power (MW)') plt.legend(title = r'$k$ (1/m$^2$)') Out[10]: <pre>&lt;matplotlib.legend.Legend at 0x1600ce130&gt;</pre> In\u00a0[11]: Copied! <pre>fig, ax = plt.subplots()\ny = np.array([g.stat('power')[-1] for g in Glist])\nixbest = y.argmax()\nGbest = Glist[ixbest]\nkbest = klist[ixbest]\nybest = y[ixbest]\nax.plot(klist, y/1e6 )\nax.scatter(kbest, ybest/1e6, marker='*', label=fr'$k$= {kbest:0.1f} 1/m$^2$') \nax.set_ylabel('end power (MW)')\nax.set_xlabel(r'$k$ (1/m$^2$)')\nplt.legend()\n</pre> fig, ax = plt.subplots() y = np.array([g.stat('power')[-1] for g in Glist]) ixbest = y.argmax() Gbest = Glist[ixbest] kbest = klist[ixbest] ybest = y[ixbest] ax.plot(klist, y/1e6 ) ax.scatter(kbest, ybest/1e6, marker='*', label=fr'$k$= {kbest:0.1f} 1/m$^2$')  ax.set_ylabel('end power (MW)') ax.set_xlabel(r'$k$ (1/m$^2$)') plt.legend() Out[11]: <pre>&lt;matplotlib.legend.Legend at 0x13fe2b100&gt;</pre> In\u00a0[12]: Copied! <pre>fig, ax = plt.subplots()\nfor k, g in zip(klist, Glist):\n    x = g.stat('zplot')\n    y = g.stat('beam_xsize')\n    if k == kbest:\n        color = 'black'\n    else:\n        color = None\n    ax.plot(x, y*1e6, label = f'{k:0.1f}', color=color)\n\nax.set_xlabel(r'$z$ (m)')\nax.set_ylabel('Beam xsize (\u00b5m)')  \n#ax.set_ylim(0, None)\nplt.legend(title = r'$k$ (1/m$^2$)')\n</pre> fig, ax = plt.subplots() for k, g in zip(klist, Glist):     x = g.stat('zplot')     y = g.stat('beam_xsize')     if k == kbest:         color = 'black'     else:         color = None     ax.plot(x, y*1e6, label = f'{k:0.1f}', color=color)  ax.set_xlabel(r'$z$ (m)') ax.set_ylabel('Beam xsize (\u00b5m)')   #ax.set_ylim(0, None) plt.legend(title = r'$k$ (1/m$^2$)') Out[12]: <pre>&lt;matplotlib.legend.Legend at 0x16063a6a0&gt;</pre> <p>Cleanup</p> In\u00a0[13]: Copied! <pre>os.remove(LATFILE)\n</pre> os.remove(LATFILE)"},{"location":"examples/genesis4/fodo_scan/#genesis4-fodo-scan","title":"Genesis4 FODO Scan\u00b6","text":"<p>LUME-Genesis makes it easy to explore a parameter space within a notebook.</p> <p>Here we will make a lattice file within the notebook, and scan the quadrupole k to find the best final power for a simple benchmark example.</p>"},{"location":"examples/genesis4/fodo_scan/#lattice","title":"Lattice\u00b6","text":"<p>Here we will use Genesis4 SASE Benchmark as the basis for a lattice, but create it here in code.</p> <p>Note that the FODO cell length is 9.5 m, and there are 13 cells, for a total length of 123.5 m.</p>"},{"location":"examples/genesis4/fodo_scan/#run1-function","title":"Run1 function\u00b6","text":"<p>Make a simple function to run a complete simulation and return a <code>Genesis4</code> object.</p>"},{"location":"examples/genesis4/fodo_scan/#scan-k1","title":"Scan k1\u00b6","text":"<p>Now scan use this function to scan various quadrupole k1. Note that Genesis4 is doing matching internally with <code>zmatch</code> in the input.</p>"},{"location":"examples/genesis4/fodo_scan_model/","title":"Genesis4 FODO Scan Model","text":"In\u00a0[1]: Copied! <pre>from genesis.version4 import Genesis4\nfrom pmd_beamphysics.units import mec2\nfrom dataclasses import dataclass\nfrom math import pi, sqrt\nimport os\nimport numpy as np\nimport matplotlib.pyplot as plt\n%config InlineBackend.figure_format = 'retina'\n</pre> from genesis.version4 import Genesis4 from pmd_beamphysics.units import mec2 from dataclasses import dataclass from math import pi, sqrt import os import numpy as np import matplotlib.pyplot as plt %config InlineBackend.figure_format = 'retina' In\u00a0[2]: Copied! <pre>def make_fodo(Lcell=9.5,\n              kL=None,\n              lambdau = 15e-3,\n              Ltot = 150,\n              Lpad = 0.685/2, # Will be adjusted slightly to make Lcell exact\n              Lquad = 0.08,\n              aw = 0.84853,\n             ):\n    if kL is None:\n        #  Optimal for flat beam\n        kL = 1/(sqrt(2) * Lcell/2)\n                         \n        # Optimal for round beam (90 deg phase advance)\n        # k1L_optimal = 2*sqrt(2) / Lcell\n    \n    k1 = kL/Lquad\n       \n    # Length for single wiggler\n    Lwig =  (Lcell - 4*Lpad - 2* Lquad) /2\n    nwig = round(Lwig / lambdau)\n      \n    # Set padding exactly\n    Lwig = lambdau * nwig\n    Lpad = round((Lcell - 2*Lwig - 2*Lquad)/4, 9) \n    \n    ncell = round(Ltot // Lcell)\n                         \n    lat = f\"\"\"\nD1: DRIFT = {{ l = {Lpad} }};\nD2: DRIFT = {{ l = {Lpad} }};\n\n# k1*L = {kL}\nQF: QUADRUPOLE = {{ l = {Lquad}, k1= { k1} }};\nQD: QUADRUPOLE = {{ l = {Lquad}, k1= {-k1} }};\n\nUND: UNDULATOR = {{ lambdau={lambdau}, nwig={nwig}, aw={aw} }};\n\nFODO: LINE= {{UND, D1,QF,D2, UND, D1,QD,D2}};\n\nLAT: LINE= {{ {ncell}*FODO}};\n    \"\"\"\n    return lat\n    \nprint(make_fodo(lambdau=30e-3, Lcell=9.5))\n</pre> def make_fodo(Lcell=9.5,               kL=None,               lambdau = 15e-3,               Ltot = 150,               Lpad = 0.685/2, # Will be adjusted slightly to make Lcell exact               Lquad = 0.08,               aw = 0.84853,              ):     if kL is None:         #  Optimal for flat beam         kL = 1/(sqrt(2) * Lcell/2)                                   # Optimal for round beam (90 deg phase advance)         # k1L_optimal = 2*sqrt(2) / Lcell          k1 = kL/Lquad             # Length for single wiggler     Lwig =  (Lcell - 4*Lpad - 2* Lquad) /2     nwig = round(Lwig / lambdau)            # Set padding exactly     Lwig = lambdau * nwig     Lpad = round((Lcell - 2*Lwig - 2*Lquad)/4, 9)           ncell = round(Ltot // Lcell)                               lat = f\"\"\" D1: DRIFT = {{ l = {Lpad} }}; D2: DRIFT = {{ l = {Lpad} }};  # k1*L = {kL} QF: QUADRUPOLE = {{ l = {Lquad}, k1= { k1} }}; QD: QUADRUPOLE = {{ l = {Lquad}, k1= {-k1} }};  UND: UNDULATOR = {{ lambdau={lambdau}, nwig={nwig}, aw={aw} }};  FODO: LINE= {{UND, D1,QF,D2, UND, D1,QD,D2}};  LAT: LINE= {{ {ncell}*FODO}};     \"\"\"     return lat      print(make_fodo(lambdau=30e-3, Lcell=9.5)) <pre>\nD1: DRIFT = { l = 0.34 };\nD2: DRIFT = { l = 0.34 };\n\n# k1*L = 0.14886458551295736\nQF: QUADRUPOLE = { l = 0.08, k1= 1.860807318911967 };\nQD: QUADRUPOLE = { l = 0.08, k1= -1.860807318911967 };\n\nUND: UNDULATOR = { lambdau=0.03, nwig=133, aw=0.84853 };\n\nFODO: LINE= {UND, D1,QF,D2, UND, D1,QD,D2};\n\nLAT: LINE= { 15*FODO};\n    \n</pre> In\u00a0[3]: Copied! <pre>def Krof(*, lambdar, lambdau, gamma):\n    \"\"\"\n    K to make lambdar resonant\n    \"\"\"\n    Ksq = 2 * (2*gamma**2*lambdar/lambdau -1 )\n    if Ksq &lt;= 0:\n        raise ValueError(f'No resonance available, lambdau must be &lt; {2*gamma**2*lambdar*1e3:0.1f}1e-3 m')\n    \n    return sqrt(Ksq )\nKrof(lambdar=1e-10, lambdau=25e-3, gamma = 11357.82) / sqrt(2)\n</pre> def Krof(*, lambdar, lambdau, gamma):     \"\"\"     K to make lambdar resonant     \"\"\"     Ksq = 2 * (2*gamma**2*lambdar/lambdau -1 )     if Ksq &lt;= 0:         raise ValueError(f'No resonance available, lambdau must be &lt; {2*gamma**2*lambdar*1e3:0.1f}1e-3 m')          return sqrt(Ksq ) Krof(lambdar=1e-10, lambdau=25e-3, gamma = 11357.82) / sqrt(2) Out[3]: <pre>0.17888711865084084</pre> In\u00a0[4]: Copied! <pre>@dataclass\nclass FODOModel:\n    \n    # Lengths\n    Lcell: float = 9.5\n    Ltot: float = 125\n    Lquad: float = 0.08\n    Lpad: float =  0.685/2\n    \n    kL: float = None # Will be picked automatically\n    \n    lambdar: float = 1e-10\n    lambdau: float = 15e-3\n    gamma: float = 11357.82\n    \n    current: float = 3000\n    delgam: float = 1.0\n    norm_emit_x: float = 0.4e-6\n    norm_emit_y: float = 0.4e-6\n    \n    nproc = 1\n    \n    seed: int = None # None will pick a random seed\n    \n    def make_lattice(self):\n        \"\"\"\n        Returns the lattice string, \n        setting aw for resonance\n        \"\"\"\n        \n        aw = Krof(lambdar=self.lambdar, lambdau=self.lambdau, gamma = self.gamma) / sqrt(2)\n        \n        return make_fodo(Lcell=self.Lcell,\n              kL=self.kL,\n              lambdau = self.lambdau,\n              Ltot = self.Ltot,\n              Lpad = self.Lpad, # Will be adjusted\n              Lquad = self.Lquad,\n              aw = aw,\n                        )\n\n    def make_genesis(self):\n        \n        if self.seed is None:\n            seed = np.random.randint(0, 1e10)\n        else:\n            seed = self.seed\n            \n        G = Genesis4()\n        G.input = {'main': [{'type': 'setup',\n           'rootname': 'Benchmark',\n           'lattice': 'genesis4.lat',\n           'beamline': 'LAT',\n           'lambda0': self.lambdar,\n           'gamma0': self.gamma,\n           'delz': 0.045,\n           'seed': seed,\n           'shotnoise': 0,\n           'beam_global_stat': True,\n           'field_global_stat': True},\n          {'type': 'lattice', 'zmatch': self.Lcell},\n          {'type': 'field',\n           'power': 5000,\n           'dgrid': 0.0002,\n           'ngrid': 255,\n           'waist_size': 3e-05},\n          {'type': 'beam', 'current': self.current, 'delgam': self.delgam, 'ex': self.norm_emit_x, 'ey': self.norm_emit_y},\n          {'type': 'track', 'zstop': self.Ltot}]}  \n        G.configure()\n        \n        lat = self.make_lattice()\n        latfile = os.path.join(G.path, 'genesis4.lat')\n        with open(latfile, 'w') as f:\n            f.write(lat)\n        G.input['main'][0]['lattice'] = latfile\n\n        return G\n    \n    def run(self):\n        G = self.make_genesis()\n        G.nproc = self.nproc\n        G.run()\n        return G\n\nF = FODOModel(Ltot = 20)\n</pre> @dataclass class FODOModel:          # Lengths     Lcell: float = 9.5     Ltot: float = 125     Lquad: float = 0.08     Lpad: float =  0.685/2          kL: float = None # Will be picked automatically          lambdar: float = 1e-10     lambdau: float = 15e-3     gamma: float = 11357.82          current: float = 3000     delgam: float = 1.0     norm_emit_x: float = 0.4e-6     norm_emit_y: float = 0.4e-6          nproc = 1          seed: int = None # None will pick a random seed          def make_lattice(self):         \"\"\"         Returns the lattice string,          setting aw for resonance         \"\"\"                  aw = Krof(lambdar=self.lambdar, lambdau=self.lambdau, gamma = self.gamma) / sqrt(2)                  return make_fodo(Lcell=self.Lcell,               kL=self.kL,               lambdau = self.lambdau,               Ltot = self.Ltot,               Lpad = self.Lpad, # Will be adjusted               Lquad = self.Lquad,               aw = aw,                         )      def make_genesis(self):                  if self.seed is None:             seed = np.random.randint(0, 1e10)         else:             seed = self.seed                      G = Genesis4()         G.input = {'main': [{'type': 'setup',            'rootname': 'Benchmark',            'lattice': 'genesis4.lat',            'beamline': 'LAT',            'lambda0': self.lambdar,            'gamma0': self.gamma,            'delz': 0.045,            'seed': seed,            'shotnoise': 0,            'beam_global_stat': True,            'field_global_stat': True},           {'type': 'lattice', 'zmatch': self.Lcell},           {'type': 'field',            'power': 5000,            'dgrid': 0.0002,            'ngrid': 255,            'waist_size': 3e-05},           {'type': 'beam', 'current': self.current, 'delgam': self.delgam, 'ex': self.norm_emit_x, 'ey': self.norm_emit_y},           {'type': 'track', 'zstop': self.Ltot}]}           G.configure()                  lat = self.make_lattice()         latfile = os.path.join(G.path, 'genesis4.lat')         with open(latfile, 'w') as f:             f.write(lat)         G.input['main'][0]['lattice'] = latfile          return G          def run(self):         G = self.make_genesis()         G.nproc = self.nproc         G.run()         return G  F = FODOModel(Ltot = 20)  In\u00a0[5]: Copied! <pre>G = F.run()\nG.plot('power', yscale='log', y2=['beam_xsize', 'beam_ysize'], ylim2=(0, 50e-6))\n</pre> G = F.run() G.plot('power', yscale='log', y2=['beam_xsize', 'beam_ysize'], ylim2=(0, 50e-6)) In\u00a0[6]: Copied! <pre>%%time\ndef run1(kL):\n    G = FODOModel(kL=kL).run()\n    return G\n\nG2=run1(0.136) # = 1.7 * .08\n</pre> %%time def run1(kL):     G = FODOModel(kL=kL).run()     return G  G2=run1(0.136) # = 1.7 * .08 <pre>CPU times: user 8.54 ms, sys: 5.66 ms, total: 14.2 ms\nWall time: 11.3 s\n</pre> In\u00a0[7]: Copied! <pre>G2.plot('power', yscale='log', y2=['beam_xsize', 'beam_ysize'], ylim2=(0, 200e-6))\n</pre> G2.plot('power', yscale='log', y2=['beam_xsize', 'beam_ysize'], ylim2=(0, 200e-6)) In\u00a0[8]: Copied! <pre>%%time\nkLlist = np.linspace(.1, .4, 10)\nGlist = [run1(kL) for kL in kLlist]\n</pre> %%time kLlist = np.linspace(.1, .4, 10) Glist = [run1(kL) for kL in kLlist] <pre>CPU times: user 87.8 ms, sys: 45 ms, total: 133 ms\nWall time: 1min 54s\n</pre> In\u00a0[9]: Copied! <pre>fig, ax = plt.subplots()\nfor k, g in zip(kLlist, Glist):\n    x = g.stat('zplot')\n    y = g.stat('power')\n    ax.plot(x, y/1e6, label = f'{k:0.3f}')\n#ax.set_yscale('log')\nax.set_xlabel(r'$z$ (m)')\nax.set_ylabel('power (MW)')\nplt.legend(title = r'$k_1L$ (1/m)')\n</pre> fig, ax = plt.subplots() for k, g in zip(kLlist, Glist):     x = g.stat('zplot')     y = g.stat('power')     ax.plot(x, y/1e6, label = f'{k:0.3f}') #ax.set_yscale('log') ax.set_xlabel(r'$z$ (m)') ax.set_ylabel('power (MW)') plt.legend(title = r'$k_1L$ (1/m)') Out[9]: <pre>&lt;matplotlib.legend.Legend at 0x160c84f70&gt;</pre> In\u00a0[10]: Copied! <pre>fig, ax = plt.subplots()\ny = np.array([g.stat('power')[-1] for g in Glist])\nixbest = y.argmax()\nGbest = Glist[ixbest]\nkbest = kLlist[ixbest]\nybest = y[ixbest]\nax.plot(kLlist, y/1e6 )\nax.scatter(kbest, ybest/1e6, marker='*', label=fr'$k_1L$= {kbest:0.1f} 1/m') \nax.set_ylabel('end power (MW)')\nax.set_xlabel(r'$k_1L$ (1/m)')\nplt.legend()\n</pre> fig, ax = plt.subplots() y = np.array([g.stat('power')[-1] for g in Glist]) ixbest = y.argmax() Gbest = Glist[ixbest] kbest = kLlist[ixbest] ybest = y[ixbest] ax.plot(kLlist, y/1e6 ) ax.scatter(kbest, ybest/1e6, marker='*', label=fr'$k_1L$= {kbest:0.1f} 1/m')  ax.set_ylabel('end power (MW)') ax.set_xlabel(r'$k_1L$ (1/m)') plt.legend() Out[10]: <pre>&lt;matplotlib.legend.Legend at 0x1610ba3a0&gt;</pre> In\u00a0[11]: Copied! <pre>fig, ax = plt.subplots()\nfor k, g in zip(kLlist, Glist):\n    x = g.stat('zplot')\n    y = g.stat('beam_xsize')\n    if k == kbest:\n        color = 'black'\n    else:\n        color = None\n    ax.plot(x, y*1e6, label = f'{k:0.3f}', color=color)\n\nax.set_xlabel(r'$z$ (m)')\nax.set_ylabel('Beam xsize (\u00b5m)')  \nax.set_ylim(0, None)\nplt.legend(title = r'$k_1L$ (1/m)')\n</pre> fig, ax = plt.subplots() for k, g in zip(kLlist, Glist):     x = g.stat('zplot')     y = g.stat('beam_xsize')     if k == kbest:         color = 'black'     else:         color = None     ax.plot(x, y*1e6, label = f'{k:0.3f}', color=color)  ax.set_xlabel(r'$z$ (m)') ax.set_ylabel('Beam xsize (\u00b5m)')   ax.set_ylim(0, None) plt.legend(title = r'$k_1L$ (1/m)') Out[11]: <pre>&lt;matplotlib.legend.Legend at 0x1610b4a30&gt;</pre> In\u00a0[12]: Copied! <pre>%%time\ndef run1(lambdau):\n    p = {}\n    p['lambdau'] = lambdau\n    G = FODOModel(**p).make_genesis()\n    G.run()\n    return G\n\nG2=run1(10e-3)\nG2.plot('power', yscale='log', y2=['beam_xsize', 'beam_ysize'], ylim2=(0, None))\n</pre> %%time def run1(lambdau):     p = {}     p['lambdau'] = lambdau     G = FODOModel(**p).make_genesis()     G.run()     return G  G2=run1(10e-3) G2.plot('power', yscale='log', y2=['beam_xsize', 'beam_ysize'], ylim2=(0, None)) <pre>CPU times: user 32.7 ms, sys: 9.86 ms, total: 42.6 ms\nWall time: 11.3 s\n</pre> In\u00a0[13]: Copied! <pre>%%time\nlambdaulist = np.linspace(10e-3, 25e-3, 10)\nGlist = [run1(lambdau) for lambdau in lambdaulist]\n</pre> %%time lambdaulist = np.linspace(10e-3, 25e-3, 10) Glist = [run1(lambdau) for lambdau in lambdaulist] <pre>CPU times: user 86.6 ms, sys: 45.8 ms, total: 132 ms\nWall time: 1min 52s\n</pre> In\u00a0[14]: Copied! <pre>fig, ax = plt.subplots()\nfor k, g in zip(lambdaulist, Glist):\n    x = g.stat('zplot')\n    y = g.stat('power')\n    ax.plot(x, y/1e6, label = f'{k*1e3:0.1f}')\nax.set_yscale('log')\nax.set_xlabel(r'$z$ (m)')\nax.set_ylabel('power (MW)')\nplt.legend(title = r'$\\lambda_u$ (mm)')\n</pre> fig, ax = plt.subplots() for k, g in zip(lambdaulist, Glist):     x = g.stat('zplot')     y = g.stat('power')     ax.plot(x, y/1e6, label = f'{k*1e3:0.1f}') ax.set_yscale('log') ax.set_xlabel(r'$z$ (m)') ax.set_ylabel('power (MW)') plt.legend(title = r'$\\lambda_u$ (mm)') Out[14]: <pre>&lt;matplotlib.legend.Legend at 0x1612b2520&gt;</pre>"},{"location":"examples/genesis4/fodo_scan_model/#genesis4-fodo-scan-model","title":"Genesis4 FODO Scan Model\u00b6","text":"<p>This is a variation on the original FODO scan notebook, using more complicated objects to automate some behavior.</p>"},{"location":"examples/genesis4/fodo_scan_model/#lattice","title":"Lattice\u00b6","text":"<p>These are the same parameters as the Genesis4 SASE Benchmark. The lattice is created here in code.</p> <p>Note that the FODO cell length is 9.5 m, and there are 13 cells, for a total length of 123.5 m.</p>"},{"location":"examples/genesis4/fodo_scan_model/#run1-function","title":"Run1 function\u00b6","text":"<p>Make a simple function to run a complete simulation and return a <code>Genesis4</code> object.</p>"},{"location":"examples/genesis4/fodo_scan_model/#scan-kl","title":"Scan kL\u00b6","text":"<p>Now scan use this function to scan various quadrupole k1. Note that Genesis4 is doing matching internally with <code>zmatch</code> in the input.</p>"},{"location":"examples/genesis4/fodo_scan_model/#scan-lambdau","title":"Scan lambdau\u00b6","text":""},{"location":"examples/genesis4/genesis4_example/","title":"Genesis4 Basic Example","text":"In\u00a0[1]: Copied! <pre>from genesis.version4 import Genesis4\n</pre> from genesis.version4 import Genesis4 <p>Instantiate the object on a value init file. This will configure a working directory that stages all input and output files.</p> In\u00a0[2]: Copied! <pre>FILE = 'data/basic4/cu_hxr.in'\n\nG = Genesis4(FILE, verbose = True)\n</pre> FILE = 'data/basic4/cu_hxr.in'  G = Genesis4(FILE, verbose = True) <pre>Configured to run in: /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp476sarxi\n</pre> <p>Input is simply a list of dicts corresponding to the namelist</p> In\u00a0[3]: Copied! <pre>G.input\n</pre> G.input Out[3]: <pre>{'main': [{'type': 'setup',\n   'rootname': 'LCLS2_HXR_9keV',\n   'lattice': '/Users/chrisonian/Code/GitHub/lume-genesis/docs/examples/genesis4/data/basic4/hxr.lat',\n   'beamline': 'HXR',\n   'lambda0': 1.3789244869952112e-10,\n   'gamma0': 19174.0776,\n   'delz': 0.026,\n   'seed': 84672,\n   'npart': 1024},\n  {'type': 'time', 'slen': 1.5e-05, 'sample': 200},\n  {'type': 'field', 'dgrid': 0.0001, 'ngrid': 101, 'accumulate': True},\n  {'type': 'profile_file',\n   'label': 'beamcurrent',\n   'xdata': array([0.00000000e+00, 7.50037502e-10, 1.50007500e-09, ...,\n          1.49984999e-05, 1.49992500e-05, 1.50000000e-05]),\n   'ydata': array([2.65147892, 2.65521019, 2.65894633, ..., 2.65894633, 2.65521019,\n          2.65147892])},\n  {'type': 'profile_file',\n   'label': 'beamgamma',\n   'xdata': array([0.00000000e+00, 7.50037502e-10, 1.50007500e-09, ...,\n          1.49984999e-05, 1.49992500e-05, 1.50000000e-05]),\n   'ydata': array([19394.23415577, 19394.21213902, 19394.19012226, ...,\n          18953.96507774, 18953.94306098, 18953.92104423])},\n  {'type': 'beam',\n   'current': '@beamcurrent',\n   'gamma': '@beamgamma',\n   'delgam': 3.97848,\n   'ex': 4e-07,\n   'ey': 4e-07,\n   'alphax': -0.7393217413918415,\n   'betax': 7.910909406464387,\n   'alphay': 1.3870723536888105,\n   'betay': 16.881178621346898},\n  {'type': 'track', 'field_dump_at_undexit': False, 'zstop': 10}]}</pre> <p>Change something</p> In\u00a0[4]: Copied! <pre>G.input['main'][6]['zstop'] = 92\n</pre> G.input['main'][6]['zstop'] = 92 In\u00a0[5]: Copied! <pre># Add writing a field file\nG.input['main'].append({'type':'write', 'field':'end'})\n\n# Add writing a beam (particle) file\nG.input['main'].append({'type':'write', 'beam':'end'})\n</pre> # Add writing a field file G.input['main'].append({'type':'write', 'field':'end'})  # Add writing a beam (particle) file G.input['main'].append({'type':'write', 'beam':'end'}) <p>Run with MPI</p> In\u00a0[6]: Copied! <pre>G.nproc = 8\nG.run()\n</pre> G.nproc = 8 G.run() <pre>Setting use_mpi = True because nproc = 8\nRunning Genesis4 in /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp476sarxi\n/opt/local/bin/mpirun -n 8 /Users/chrisonian/Code/GitHub/Genesis-1.3-Version4/build/genesis4 genesis4.in\n---------------------------------------------\nGENESIS - Version 4.6.2 (beta) has started...\nCompile info: Compiled by chrisonian at 2023-06-27 18:49:35 [UTC] from Git Commit ID: 431599433d0af1de2dfbc872ff6e5289dfe690ce\nStarting Time: Wed Nov  8 09:31:05 2023\n\nMPI-Comm Size: 8 nodes\n\nParsing lattice file...\nSetting up time window of 15.0027 microns with 544 sample points...\nGenerating input radiation field for HARM = 1 ...\nAdding profile with label: beamcurrent\nAdding profile with label: beamgamma\nGenerating input particle distribution...\n\nRunning Core Simulation...\nTime-dependent run with 544 slices for a time window of 15.0027 microns\nInitial analysis of electron beam and radiation field...\n  Calculation: 10% done\n  Calculation: 20% done\n  Calculation: 30% done\n  Calculation: 40% done\n  Calculation: 50% done\n  Calculation: 60% done\n  Calculation: 70% done\n  Calculation: 80% done\n  Calculation: 90% done\nCalculation terminated due to requested stop.\nWriting output file...\n\nCore Simulation done.\nEnd of Track\nWriting field distribution to file: end.fld.h5 ...\nWriting particle distribution to file: end.par.h5 ...\n\nProgram is terminating...\nEnding Time: Wed Nov  8 09:33:30 2023\nTotal Wall Clock Time: 142.35 seconds\n-------------------------------------\nFinished.\nLoading main output: /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp476sarxi/LCLS2_HXR_9keV.out.h5\n</pre> In\u00a0[7]: Copied! <pre>G.output.keys()\n</pre> G.output.keys() Out[7]: <pre>dict_keys(['run_info', 'outfile', 'Beam/LSCfield', 'Beam/alphax', 'Beam/alphay', 'Beam/betax', 'Beam/betay', 'Beam/bunching', 'Beam/bunchingphase', 'Beam/current', 'Beam/efield', 'Beam/emitx', 'Beam/emity', 'Beam/energy', 'Beam/energyspread', 'Beam/pxposition', 'Beam/pyposition', 'Beam/wakefield', 'Beam/xposition', 'Beam/xsize', 'Beam/yposition', 'Beam/ysize', 'Field/dgrid', 'Field/intensity-farfield', 'Field/intensity-nearfield', 'Field/ngrid', 'Field/phase-farfield', 'Field/phase-nearfield', 'Field/power', 'Field/xdivergence', 'Field/xpointing', 'Field/xposition', 'Field/xsize', 'Field/ydivergence', 'Field/ypointing', 'Field/yposition', 'Field/ysize', 'Global/frequency', 'Global/gamma0', 'Global/lambdaref', 'Global/one4one', 'Global/s', 'Global/sample', 'Global/scan', 'Global/slen', 'Global/time', 'Lattice/aw', 'Lattice/ax', 'Lattice/ay', 'Lattice/chic_angle', 'Lattice/chic_lb', 'Lattice/chic_ld', 'Lattice/chic_lt', 'Lattice/cx', 'Lattice/cy', 'Lattice/dz', 'Lattice/gradx', 'Lattice/grady', 'Lattice/ku', 'Lattice/kx', 'Lattice/ky', 'Lattice/phaseshift', 'Lattice/qf', 'Lattice/qx', 'Lattice/qy', 'Lattice/slippage', 'Lattice/z', 'Lattice/zplot', 'Meta/Beamdumps/ndumps', 'Meta/Fielddumps/ndumps', 'Meta/HOST', 'Meta/InputFile', 'Meta/LatticeFile', 'Meta/TimeStamp', 'Meta/User', 'Meta/Version/Beta', 'Meta/Version/Build_Info', 'Meta/Version/Major', 'Meta/Version/Minor', 'Meta/Version/Revision', 'Meta/cwd', 'Meta/mpisize', 'field', 'field_files', 'particles', 'particle_files'])</pre> <p>This is the output file that was loaded</p> In\u00a0[8]: Copied! <pre>G.output['outfile']\n</pre> G.output['outfile'] Out[8]: <pre>'/var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp476sarxi/LCLS2_HXR_9keV.out.h5'</pre> In\u00a0[9]: Copied! <pre>G.expand_alias('sigma_x')\n</pre> G.expand_alias('sigma_x') Out[9]: <pre>'sigma_x'</pre> <p>There are many outputs. <code>.output_info()</code> gives a convenient table describing what was read in.</p> In\u00a0[10]: Copied! <pre>G.output_info()\n</pre> G.output_info() <pre>Output data\n\nkey                       value              unit\n--------------------------------------------------\nBeam/LSCfield             array: (2544, 544)  eV/m\nBeam/alphax               array: (1, 544)    rad\nBeam/alphay               array: (1, 544)    rad\nBeam/betax                array: (1, 544)    m\nBeam/betay                array: (1, 544)    m\nBeam/bunching             array: (2544, 544)  \nBeam/bunchingphase        array: (2544, 544)  rad\nBeam/current              array: (2544, 544)  A\nBeam/efield               array: (2544, 544)  eV/m\nBeam/emitx                array: (1, 544)    m\nBeam/emity                array: (1, 544)    m\nBeam/energy               array: (2544, 544)  m_ec^2\nBeam/energyspread         array: (2544, 544)  m_ec^2\nBeam/pxposition           array: (2544, 544)  rad\nBeam/pyposition           array: (2544, 544)  rad\nBeam/wakefield            array: (2544, 544)  eV/m\nBeam/xposition            array: (2544, 544)  m\nBeam/xsize                array: (2544, 544)  m\nBeam/yposition            array: (2544, 544)  m\nBeam/ysize                array: (2544, 544)  m\nField/dgrid               2e-06  \nField/intensity-farfield  array: (2544, 544)  W/rad^2\nField/intensity-nearfield array: (2544, 544)  W/m^2\nField/ngrid               101.0  \nField/phase-farfield      array: (2544, 544)  rad\nField/phase-nearfield     array: (2544, 544)  rad\nField/power               array: (2544, 544)  W\nField/xdivergence         array: (2544, 544)  rad\nField/xpointing           array: (2544, 544)  rad\nField/xposition           array: (2544, 544)  m\nField/xsize               array: (2544, 544)  m\nField/ydivergence         array: (2544, 544)  rad\nField/ypointing           array: (2544, 544)  rad\nField/yposition           array: (2544, 544)  m\nField/ysize               array: (2544, 544)  m\nGlobal/frequency          array: (544,)      \nGlobal/gamma0             19174.0776  \nGlobal/lambdaref          1.3789244869952112e-10  \nGlobal/one4one            0.0  \nGlobal/s                  array: (544,)      \nGlobal/sample             200.0  \nGlobal/scan               0.0  \nGlobal/slen               1.5002698418507897e-05  \nGlobal/time               1.0  \nLattice/aw                array: (4332,)     \nLattice/ax                array: (4332,)     \nLattice/ay                array: (4332,)     \nLattice/chic_angle        array: (4332,)     \nLattice/chic_lb           array: (4332,)     \nLattice/chic_ld           array: (4332,)     \nLattice/chic_lt           array: (4332,)     \nLattice/cx                array: (4332,)     \nLattice/cy                array: (4332,)     \nLattice/dz                array: (4332,)     \nLattice/gradx             array: (4332,)     \nLattice/grady             array: (4332,)     \nLattice/ku                array: (4332,)     \nLattice/kx                array: (4332,)     \nLattice/ky                array: (4332,)     \nLattice/phaseshift        array: (4332,)     \nLattice/qf                array: (4332,)     \nLattice/qx                array: (4332,)     \nLattice/qy                array: (4332,)     \nLattice/slippage          array: (4332,)     \nLattice/z                 array: (4332,)     \nLattice/zplot             array: (2544,)     \nMeta/Beamdumps/ndumps     0  \nMeta/Fielddumps/ndumps    0  \nMeta/HOST                 Undefined\nMeta/InputFile            long str:  &amp;setup rootname = L...\nMeta/LatticeFile          long str: ## Quads ### QHXH17:...\nMeta/TimeStamp            Wed Nov  8 09:33:29 2023\n\nMeta/User                 chrisonian\nMeta/Version/Beta         1.0  \nMeta/Version/Build_Info   Compiled by chrisonian at 2023-06-27 18:49:35 [UTC] from Git Commit ID: 431599433d0af1de2dfbc872ff6e5289dfe690ce\nMeta/Version/Major        4.0  \nMeta/Version/Minor        6.0  \nMeta/Version/Revision     2.0  \nMeta/cwd                  /private/var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp476sarxi\nMeta/mpisize              8.0  \n\nfield_files               ['/var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp476sarxi/end.fld.h5']\noutfile                   /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp476sarxi/LCLS2_HXR_9keV.out.h5\nparticle_files            ['/var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp476sarxi/end.par.h5']\n\n\n</pre> In\u00a0[11]: Copied! <pre>G.output['field_files']\n</pre> G.output['field_files'] Out[11]: <pre>['/var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp476sarxi/end.fld.h5']</pre> <p>This will load all files in the list</p> In\u00a0[12]: Copied! <pre>G.load_fields()\n</pre> G.load_fields() <pre>Loaded field data: end\n</pre> In\u00a0[13]: Copied! <pre>G.output['field'].keys()\n</pre> G.output['field'].keys() Out[13]: <pre>dict_keys(['end'])</pre> <p>This field data has two parts: basic parameters <code>param</code>, and the raw 3D complex array <code>dfl</code>:</p> In\u00a0[14]: Copied! <pre>G.output['field']['end']['param']\n</pre> G.output['field']['end']['param'] Out[14]: <pre>{'gridpoints': 101,\n 'gridsize': 2e-06,\n 'refposition': 0.0,\n 'wavelength': 1.3789244869952112e-10,\n 'slicecount': 544,\n 'slicespacing': 2.7578489739904225e-08}</pre> In\u00a0[15]: Copied! <pre>G.output['field']['end']['dfl'].shape\n</pre> G.output['field']['end']['dfl'].shape Out[15]: <pre>(101, 101, 544)</pre> <p><code>.field</code> is a convenience property that points to this</p> In\u00a0[16]: Copied! <pre>G.field.keys()\n</pre> G.field.keys() Out[16]: <pre>dict_keys(['end'])</pre> In\u00a0[17]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n%config InlineBackend.figure_format = 'retina'\n</pre> import numpy as np import matplotlib.pyplot as plt %config InlineBackend.figure_format = 'retina' In\u00a0[18]: Copied! <pre># Sum over y and compute the absolute square \ndfl = G.field['end']['dfl']\nparam = G.field['end']['param']\ndat2 = np.abs(np.sum(dfl, axis=1))**2\n</pre> # Sum over y and compute the absolute square  dfl = G.field['end']['dfl'] param = G.field['end']['param'] dat2 = np.abs(np.sum(dfl, axis=1))**2 In\u00a0[19]: Copied! <pre>plt.imshow(dat2)\n</pre> plt.imshow(dat2) Out[19]: <pre>&lt;matplotlib.image.AxesImage at 0x13455d590&gt;</pre> In\u00a0[20]: Copied! <pre>def plot_slice(i=0):\n    \n    dat = np.angle(dfl[:,:,i])\n    \n    dx = param['gridsize']*1e6\n    plt.xlabel('x (\u00b5m)')\n    plt.xlabel('y (\u00b5m)')\n    plt.title(f'Phase for slize {i}')\n    plt.imshow(dat.T, origin='lower', extent=[-dx,dx,-dx,dx])\nplot_slice(i=100)\n</pre> def plot_slice(i=0):          dat = np.angle(dfl[:,:,i])          dx = param['gridsize']*1e6     plt.xlabel('x (\u00b5m)')     plt.xlabel('y (\u00b5m)')     plt.title(f'Phase for slize {i}')     plt.imshow(dat.T, origin='lower', extent=[-dx,dx,-dx,dx]) plot_slice(i=100) In\u00a0[21]: Copied! <pre>G.output['particle_files']\n</pre> G.output['particle_files'] Out[21]: <pre>['/var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp476sarxi/end.par.h5']</pre> In\u00a0[22]: Copied! <pre>G.load_particles()\n</pre> G.load_particles() <pre>Loaded particle data: 'end' as a ParticleGroup with 557056 particles\n</pre> In\u00a0[23]: Copied! <pre>G.output['particles']\n</pre> G.output['particles'] Out[23]: <pre>{'end': &lt;ParticleGroup with 557056 particles at 0x104bd0e90&gt;}</pre> In\u00a0[24]: Copied! <pre>P = G.output['particles']['end']\n</pre> P = G.output['particles']['end'] In\u00a0[25]: Copied! <pre>P.plot('z', 'energy')\n</pre> P.plot('z', 'energy') <p>Change to z coordinates to see the current. Note that the head of the bunch is now on the left.</p> In\u00a0[26]: Copied! <pre>P.drift_to_z()\nP.plot('t', 'energy')\n</pre> P.drift_to_z() P.plot('t', 'energy') <p>Check some statistics</p> In\u00a0[27]: Copied! <pre>P['norm_emit_x'], P['norm_emit_y'], P['mean_gamma']\n</pre> P['norm_emit_x'], P['norm_emit_y'], P['mean_gamma'] Out[27]: <pre>(4.0001113199173896e-07, 4.0003448307265306e-07, 19172.276214586833)</pre> In\u00a0[28]: Copied! <pre>wavelength = G.input['main'][0]['lambda0']\nbunching_key = f'bunching_{wavelength}'\nP.drift_to_t()\n\nP.slice_plot(bunching_key, n_slice=1000)\n</pre> wavelength = G.input['main'][0]['lambda0'] bunching_key = f'bunching_{wavelength}' P.drift_to_t()  P.slice_plot(bunching_key, n_slice=1000) In\u00a0[29]: Copied! <pre># Genesis4 data\nfinal_bunching = G.output['Beam/bunching'][-1,:]\ncurrent = G.output['Beam/current'][-1,:]\ns = G.output['Global/s']\n\n\n# ParticleGroup data\nss = P.slice_statistics(bunching_key, n_slice=len(s))\nss.keys()\nx = ss['mean_z']\ny = ss[bunching_key]\n</pre> # Genesis4 data final_bunching = G.output['Beam/bunching'][-1,:] current = G.output['Beam/current'][-1,:] s = G.output['Global/s']   # ParticleGroup data ss = P.slice_statistics(bunching_key, n_slice=len(s)) ss.keys() x = ss['mean_z'] y = ss[bunching_key]  <p>Compare</p> In\u00a0[30]: Copied! <pre>fig, ax = plt.subplots()\nax.plot(x*1e6, y, label='ParticleGroup')\nax.plot(s*1e6, final_bunching, '--', label='Genesis4 output')\nax.set_xlabel('s (\u00b5m)')\nax.set_ylabel('bunching')\nplt.legend()\n</pre> fig, ax = plt.subplots() ax.plot(x*1e6, y, label='ParticleGroup') ax.plot(s*1e6, final_bunching, '--', label='Genesis4 output') ax.set_xlabel('s (\u00b5m)') ax.set_ylabel('bunching') plt.legend() Out[30]: <pre>&lt;matplotlib.legend.Legend at 0x137b514d0&gt;</pre> <p>This is the average bunching from the ParticleGroup:</p> In\u00a0[31]: Copied! <pre>P.bunching(wavelength)\n</pre> P.bunching(wavelength) Out[31]: <pre>0.016934747588526904</pre> <p>That agrees with the appropriate averaging of Genesis4's bunching calc:</p> In\u00a0[32]: Copied! <pre>G.stat('bunching')[-1]\n</pre> G.stat('bunching')[-1] Out[32]: <pre>0.016934747588491415</pre> In\u00a0[33]: Copied! <pre>G.plot('bunching')\n</pre> G.plot('bunching') <p>Check the total charge in pC:</p> In\u00a0[34]: Copied! <pre>P['charge'] / 1e-12 # pC\n</pre> P['charge'] / 1e-12 # pC Out[34]: <pre>50.1584225612439</pre> In\u00a0[35]: Copied! <pre>G.units('Beam/betax')\n</pre> G.units('Beam/betax') Out[35]: <pre>pmd_unit('m', 1, (1, 0, 0, 0, 0, 0, 0))</pre> In\u00a0[36]: Copied! <pre>G.plot()\n</pre> G.plot() <p>Left and right axes can be set this way:</p> In\u00a0[37]: Copied! <pre>G.plot('field_energy', yscale='log', y2 = ['beam_xsize', 'beam_ysize'], ylim2=(0, 100e-6))\n</pre> G.plot('field_energy', yscale='log', y2 = ['beam_xsize', 'beam_ysize'], ylim2=(0, 100e-6)) <p>By default, these plots average over slices. In the case of beam sizes, simply averaging these does not take into account the effect of misaligned slices. To plot this, LUME-Genesis provides additional <code>beam_sigma_x</code>, <code>beam_sima_y</code>, <code>beam_sigma_energy</code> keys that properly project these quantities. The difference is noticable in the energy spread calculation:</p> In\u00a0[38]: Copied! <pre>G.plot(['beam_sigma_energy', 'Beam/energyspread'], ylim=(0, 100))\n</pre> G.plot(['beam_sigma_energy', 'Beam/energyspread'], ylim=(0, 100)) In\u00a0[39]: Copied! <pre>G.plot(['field_xsize', 'field_ysize'])\n</pre> G.plot(['field_xsize', 'field_ysize']) In\u00a0[40]: Copied! <pre>plt.imshow(G.output['Field/power'], aspect='auto')\n</pre> plt.imshow(G.output['Field/power'], aspect='auto') Out[40]: <pre>&lt;matplotlib.image.AxesImage at 0x137e4a790&gt;</pre> In\u00a0[41]: Copied! <pre>afile = G.archive()\n</pre> afile = G.archive() <pre>Archiving to file genesis4_faf7a4a78b08ececc10365f5d8a22033.h5\n</pre> In\u00a0[42]: Copied! <pre># This is not yet implemented\ntry:\n    G.from_archive(afile)\nexcept NotImplementedError:\n    print('from_archive is not implemented')\n</pre> # This is not yet implemented try:     G.from_archive(afile) except NotImplementedError:     print('from_archive is not implemented') <pre>from_archive is not implemented\n</pre> In\u00a0[43]: Copied! <pre>G.load_output()\n</pre> G.load_output() <pre>Loading main output: /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp476sarxi/LCLS2_HXR_9keV.out.h5\n</pre> In\u00a0[44]: Copied! <pre>import os\nos.makedirs('temp/', exist_ok=True)\nG.write_input('temp/')\n</pre> import os os.makedirs('temp/', exist_ok=True) G.write_input('temp/') <p>Now run on the command line:</p> In\u00a0[45]: Copied! <pre>!cd temp;./run &gt;log.txt\n</pre> !cd temp;./run &gt;log.txt <p>Using the <code>use_temp_dir=False</code> and <code>workdir</code> options, the input and output data can be loaded into a new Genesis4 object:</p> In\u00a0[46]: Copied! <pre>G2 = Genesis4('temp/genesis4.in', use_temp_dir = False, workdir = 'temp/', verbose=True)\nG2.load_output()\n</pre> G2 = Genesis4('temp/genesis4.in', use_temp_dir = False, workdir = 'temp/', verbose=True) G2.load_output() <pre>Configured to run in: temp/\nLoading main output: temp/LCLS2_HXR_9keV.out.h5\n</pre> In\u00a0[47]: Copied! <pre>G2.plot()\n</pre> G2.plot() <p>Cleanup:</p> In\u00a0[48]: Copied! <pre>import shutil\nshutil.rmtree('temp')\n</pre> import shutil shutil.rmtree('temp') In\u00a0[49]: Copied! <pre>from dataclasses import dataclass\n\n@dataclass\nclass Setup:\n    rootname: str = None\n    lattice: str = None\n    beamline: str = None\n    gamma0: float = 11350.3\n    lambda0: float = 1e-10\n    delz: float = 0.015\n    seed: int = 123456789\n    npart: int = 8192\n    nbins: int = 4\n    one4one: bool = False\n    shotnoise: bool = True\n    beam_global_stat: bool = False\n    field_global_stat: bool = False\n    exclude_spatial_output: bool = False\n    exclude_fft_output: bool = False\n    exclude_intensity_output: bool = False\n    exclude_energy_output: bool = False\n    exclude_aux_output: bool = False\n    exclude_current_output: bool = True\n</pre> from dataclasses import dataclass  @dataclass class Setup:     rootname: str = None     lattice: str = None     beamline: str = None     gamma0: float = 11350.3     lambda0: float = 1e-10     delz: float = 0.015     seed: int = 123456789     npart: int = 8192     nbins: int = 4     one4one: bool = False     shotnoise: bool = True     beam_global_stat: bool = False     field_global_stat: bool = False     exclude_spatial_output: bool = False     exclude_fft_output: bool = False     exclude_intensity_output: bool = False     exclude_energy_output: bool = False     exclude_aux_output: bool = False     exclude_current_output: bool = True In\u00a0[50]: Copied! <pre>dat = {\n    'type':'setup',\n   'rootname': 'LCLS2_HXR_9keV',\n   'lattice': 'data/basic4/hxr.lat',\n   'beamline': 'HXR',\n   'lambda0': 1.3789244869952112e-10,\n   'gamma0': 19174.0776,\n   'delz': 0.026,\n   'seed': 84672,\n   'npart': 1024}\n\nlookup = {'setup':Setup}\n\ndef make(dat):\n    type = dat.pop('type')\n    return lookup[type](**dat)\ns = make(dat)\ns\n</pre> dat = {     'type':'setup',    'rootname': 'LCLS2_HXR_9keV',    'lattice': 'data/basic4/hxr.lat',    'beamline': 'HXR',    'lambda0': 1.3789244869952112e-10,    'gamma0': 19174.0776,    'delz': 0.026,    'seed': 84672,    'npart': 1024}  lookup = {'setup':Setup}  def make(dat):     type = dat.pop('type')     return lookup[type](**dat) s = make(dat) s Out[50]: <pre>Setup(rootname='LCLS2_HXR_9keV', lattice='data/basic4/hxr.lat', beamline='HXR', gamma0=19174.0776, lambda0=1.3789244869952112e-10, delz=0.026, seed=84672, npart=1024, nbins=4, one4one=False, shotnoise=True, beam_global_stat=False, field_global_stat=False, exclude_spatial_output=False, exclude_fft_output=False, exclude_intensity_output=False, exclude_energy_output=False, exclude_aux_output=False, exclude_current_output=True)</pre> In\u00a0[51]: Copied! <pre>s0 = Setup()\n</pre> s0 = Setup() In\u00a0[52]: Copied! <pre># These are the keys that are different from default:\nfrom dataclasses import asdict\nd2 = asdict(s0)\nfor k in list(d2):\n    if getattr(s, k) == d2[k]:\n        d2.pop(k)\nlist(d2)\n</pre> # These are the keys that are different from default: from dataclasses import asdict d2 = asdict(s0) for k in list(d2):     if getattr(s, k) == d2[k]:         d2.pop(k) list(d2) Out[52]: <pre>['rootname',\n 'lattice',\n 'beamline',\n 'gamma0',\n 'lambda0',\n 'delz',\n 'seed',\n 'npart']</pre>"},{"location":"examples/genesis4/genesis4_example/#genesis4-basic-example","title":"Genesis4 Basic Example\u00b6","text":"<p>This will show the basic usage of LUME-Genesis.</p>"},{"location":"examples/genesis4/genesis4_example/#output","title":"Output\u00b6","text":"<p>The main output is an HDF5. The Genesis4 object loads this data into a flat dict</p>"},{"location":"examples/genesis4/genesis4_example/#fields","title":"Fields\u00b6","text":"<p>Field files can be very large and are not loaded by default. Instead, the files found are collected as a list:</p>"},{"location":"examples/genesis4/genesis4_example/#visualize-field","title":"Visualize Field\u00b6","text":""},{"location":"examples/genesis4/genesis4_example/#particles","title":"Particles\u00b6","text":"<p>Particle files can be read in as openPMD-beamphysics <code>ParticleGroup</code> objects.</p>"},{"location":"examples/genesis4/genesis4_example/#bunching","title":"Bunching\u00b6","text":""},{"location":"examples/genesis4/genesis4_example/#units","title":"Units\u00b6","text":"<p>Each item in the output dict has a corresponding units</p>"},{"location":"examples/genesis4/genesis4_example/#plotting","title":"Plotting\u00b6","text":"<p>Convenient plotting of the data in <code>.output</code> is provided by <code>.plot</code>. The default is to plot the power. Depending on the key these statistics are averaged or integrated over the slices. Some keys like <code>power</code> are converted to <code>peak_power</code>, while <code>field_energy</code> is the integral over <code>field_power</code>.</p>"},{"location":"examples/genesis4/genesis4_example/#archiving","title":"Archiving\u00b6","text":""},{"location":"examples/genesis4/genesis4_example/#manual-loading-of-genesis4-data","title":"Manual loading of Genesis4 data\u00b6","text":"<p>Sometimes it is necessary to run Genesis4 manually, and load the output into LUME-Genesis for further analysis.</p> <p>First, let's create some input to run in a local directory <code>temp/</code>:</p>"},{"location":"examples/genesis4/genesis4_example/#future-work","title":"Future work\u00b6","text":""},{"location":"examples/genesis4/genesis4_field/","title":"Field Analysis","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>import numpy as np\nfrom math import pi\nfrom scipy.constants import c, e, epsilon_0\n# h in eV\nimport scipy\nh = scipy.constants.value('Planck constant in eV/Hz')\nZ0 = pi * 119.916983 # V^2 / m\n\nimport matplotlib.pyplot as plt\n%config InlineBackend.figure_format = 'retina'\n\nfrom genesis import Genesis4\n</pre> import numpy as np from math import pi from scipy.constants import c, e, epsilon_0 # h in eV import scipy h = scipy.constants.value('Planck constant in eV/Hz') Z0 = pi * 119.916983 # V^2 / m  import matplotlib.pyplot as plt %config InlineBackend.figure_format = 'retina'  from genesis import Genesis4 In\u00a0[3]: Copied! <pre>%%time\nG = Genesis4('data/basic4/cu_hxr.in')\nG.input['main'][1]['sample'] = 20\nG.input['main'][6]['zstop'] = 60\nG.input['main'].append({'type':'write', 'field':'end'})\nG.nproc = 8\nG.run()\n</pre> %%time G = Genesis4('data/basic4/cu_hxr.in') G.input['main'][1]['sample'] = 20 G.input['main'][6]['zstop'] = 60 G.input['main'].append({'type':'write', 'field':'end'}) G.nproc = 8 G.run() <pre>CPU times: user 35.1 ms, sys: 308 ms, total: 343 ms\nWall time: 16min 10s\n</pre> In\u00a0[4]: Copied! <pre>G.plot('field_energy', y2=['field_xsize', 'field_ysize'], ylim2 =[0, 100e-6])\n</pre> G.plot('field_energy', y2=['field_xsize', 'field_ysize'], ylim2 =[0, 100e-6]) In\u00a0[5]: Copied! <pre>G.verbose=True\nG.load_fields()\n</pre> G.verbose=True G.load_fields() <pre>Loaded field data: end\n</pre> <p>The full field data is stored as a 3D array of complex numbers <code>DFL</code> in units of <code>sqrt(W)</code>. The relation of this and the electric field <code>E</code> in V/m is <code>E = DFL * sqrt(2*Z0) / \u0394</code>, where <code>Z0 = \u03c0 * 119.9169832 V^2/W</code> exactly and <code>\u0394</code> is the grid spacing.</p> In\u00a0[6]: Copied! <pre>DFL = G.field['end']['dfl'] # sqrt(W)\n\nDFL.dtype, DFL.shape\n</pre> DFL = G.field['end']['dfl'] # sqrt(W)  DFL.dtype, DFL.shape Out[6]: <pre>(dtype('complex128'), (101, 101, 5440))</pre> In\u00a0[7]: Copied! <pre>param = G.field['end']['param']\n\nparam\n</pre> param = G.field['end']['param']  param Out[7]: <pre>{'gridpoints': 101,\n 'gridsize': 2e-06,\n 'refposition': 0.0,\n 'wavelength': 1.3789244869952112e-10,\n 'slicecount': 5440,\n 'slicespacing': 2.7578489739904224e-09}</pre> <p>Gather some convenient variables and arrays:</p> In\u00a0[8]: Copied! <pre>Ns = param['slicecount']\nds = param['slicespacing']\n\u03bb0 = param['wavelength']\nf0 = c / \u03bb0\ndt = ds / c \n\u0394 = param['gridsize']\n\ns = np.arange(0, Ns) * ds\nt = -s/c\n</pre> Ns = param['slicecount'] ds = param['slicespacing'] \u03bb0 = param['wavelength'] f0 = c / \u03bb0 dt = ds / c  \u0394 = param['gridsize']  s = np.arange(0, Ns) * ds t = -s/c In\u00a0[9]: Copied! <pre>power0 = G.output['Field/power'][-1,:] # W\n</pre> power0 = G.output['Field/power'][-1,:] # W In\u00a0[10]: Copied! <pre>power1 = np.sum(np.sum(np.abs(DFL)**2, axis = 0), axis=0) # W\n</pre> power1 = np.sum(np.sum(np.abs(DFL)**2, axis = 0), axis=0) # W <p>These are the same:</p> In\u00a0[11]: Copied! <pre>np.allclose(power0, power1)\n</pre> np.allclose(power0, power1) Out[11]: <pre>True</pre> In\u00a0[12]: Copied! <pre>fig, ax = plt.subplots()\nax.plot(s * 1e6, power0 /1e9)\nax.set_xlabel('s (\u00b5m)')\nax.set_ylabel('power (GW)')\n</pre> fig, ax = plt.subplots() ax.plot(s * 1e6, power0 /1e9) ax.set_xlabel('s (\u00b5m)') ax.set_ylabel('power (GW)') Out[12]: <pre>Text(0, 0.5, 'power (GW)')</pre> In\u00a0[13]: Copied! <pre>energy1 = np.trapz(power1, dx = dt)\n\nenergy1 # J\n</pre> energy1 = np.trapz(power1, dx = dt)  energy1 # J Out[13]: <pre>3.4988313433626924e-05</pre> In\u00a0[14]: Copied! <pre>np.sum(power1)*dt # J\n</pre> np.sum(power1)*dt # J Out[14]: <pre>3.498831343912882e-05</pre> In\u00a0[15]: Copied! <pre>intensity0 = G.output['Field/intensity-nearfield'][-1,:] # W/m^2\nphase0 = G.output['Field/phase-nearfield'][-1,:] # radian\n</pre> intensity0 = G.output['Field/intensity-nearfield'][-1,:] # W/m^2 phase0 = G.output['Field/phase-nearfield'][-1,:] # radian In\u00a0[16]: Copied! <pre>icenter = param['gridpoints']//2\nfield1= DFL[icenter, icenter, :]  # sqrt(W)\nphase1 = np.angle(field1) # radian\n\nintensity1 = np.abs(field1**2)/ \u0394**2 # W/m^2\n</pre> icenter = param['gridpoints']//2 field1= DFL[icenter, icenter, :]  # sqrt(W) phase1 = np.angle(field1) # radian  intensity1 = np.abs(field1**2)/ \u0394**2 # W/m^2 <p>These are the same:</p> In\u00a0[17]: Copied! <pre>np.allclose(intensity0, intensity1)\n</pre> np.allclose(intensity0, intensity1) Out[17]: <pre>True</pre> In\u00a0[18]: Copied! <pre>np.allclose(phase0, phase1)\n</pre> np.allclose(phase0, phase1) Out[18]: <pre>True</pre> In\u00a0[19]: Copied! <pre>fig, ax = plt.subplots()\nax.plot(s * 1e6, intensity0)\nax.set_xlabel('s (\u00b5m)')\nax.set_ylabel(r'intensity (W/m$^2$)')\n</pre> fig, ax = plt.subplots() ax.plot(s * 1e6, intensity0) ax.set_xlabel('s (\u00b5m)') ax.set_ylabel(r'intensity (W/m$^2$)') Out[19]: <pre>Text(0, 0.5, 'intensity (W/m$^2$)')</pre> <p>The same field can be reconstructed from these arrays</p> In\u00a0[20]: Copied! <pre>field0 = np.sqrt(intensity0) * np.exp(1j * phase0) * \u0394 # sqrt(W)\n</pre> field0 = np.sqrt(intensity0) * np.exp(1j * phase0) * \u0394 # sqrt(W) <p>These are the same:</p> In\u00a0[21]: Copied! <pre>np.allclose(field0, field1)\n</pre> np.allclose(field0, field1) Out[21]: <pre>True</pre> In\u00a0[22]: Copied! <pre>def spectrum_from_field(field, dt=1):\n    \"\"\"\n    Calculates the spectrum (fourier transformed field)\n    from a complex field array with spacing dt.\n    \n    Parameters\n    ----------\n    field: nd.array of shape (n,) \n        Complex field\n        \n    dt: float\n        Spacing of the field data in some units (e.g. 's')\n    \n    Returns\n    -------\n    freqs: nd.array of shape (n,)\n        Frequencies in reciprocal space with inverse units (e.g. 'Hz = 1/s')\n        \n    spectrum: nd.array of shape (n,)\n        The fourier transformed field\n    \n    \"\"\"\n    assert len(field.shape) == 1, 'Only 1D arrays are currently supported'\n    spectrum = np.fft.fftshift(np.fft.fft(field))* dt\n    \n    ns = len(field)\n    freqs = np.fft.fftshift(np.fft.fftfreq(ns, dt))\n\n    return freqs, spectrum\n</pre> def spectrum_from_field(field, dt=1):     \"\"\"     Calculates the spectrum (fourier transformed field)     from a complex field array with spacing dt.          Parameters     ----------     field: nd.array of shape (n,)          Complex field              dt: float         Spacing of the field data in some units (e.g. 's')          Returns     -------     freqs: nd.array of shape (n,)         Frequencies in reciprocal space with inverse units (e.g. 'Hz = 1/s')              spectrum: nd.array of shape (n,)         The fourier transformed field          \"\"\"     assert len(field.shape) == 1, 'Only 1D arrays are currently supported'     spectrum = np.fft.fftshift(np.fft.fft(field))* dt          ns = len(field)     freqs = np.fft.fftshift(np.fft.fftfreq(ns, dt))      return freqs, spectrum In\u00a0[23]: Copied! <pre>freqs, spectrum = spectrum_from_field(field0, dt)\n\n# Frequency spacing\n#df = np.diff(freqs)[0] # Hz\n\ndf = 1/(dt*len(field0))\n\ndf\n</pre> freqs, spectrum = spectrum_from_field(field0, dt)  # Frequency spacing #df = np.diff(freqs)[0] # Hz  df = 1/(dt*len(field0))  df Out[23]: <pre>19982569111045.027</pre> <p>Check Plancherel theorem</p> In\u00a0[24]: Copied! <pre>np.sum(np.abs(field0)**2) * dt # J\n</pre> np.sum(np.abs(field0)**2) * dt # J  Out[24]: <pre>1.173958808212307e-07</pre> In\u00a0[25]: Copied! <pre>np.sum(np.abs(spectrum)**2) * df # J\n</pre> np.sum(np.abs(spectrum)**2) * df # J  Out[25]: <pre>1.1739588082123071e-07</pre> In\u00a0[26]: Copied! <pre>freqs, spectrum = spectrum_from_field(field0, dt)\n\nfig, ax = plt.subplots()\n\nphoton_energies = h*(freqs + f0) # eV\nspectral_fluence =  np.abs(spectrum**2) / \u0394**2 / h # J/m^2/eV\n\nax.plot(photon_energies, spectral_fluence)\nax.set_xlabel('photon energy (eV)')\nax.set_ylabel(r'spectral fluence (J/m$^2$/eV)')\n</pre> freqs, spectrum = spectrum_from_field(field0, dt)  fig, ax = plt.subplots()  photon_energies = h*(freqs + f0) # eV spectral_fluence =  np.abs(spectrum**2) / \u0394**2 / h # J/m^2/eV  ax.plot(photon_energies, spectral_fluence) ax.set_xlabel('photon energy (eV)') ax.set_ylabel(r'spectral fluence (J/m$^2$/eV)') Out[26]: <pre>Text(0, 0.5, 'spectral fluence (J/m$^2$/eV)')</pre> In\u00a0[27]: Copied! <pre>fig, ax = plt.subplots()\nJ_per_photon = (h*(freqs + f0)*e) # note h is in eV/Hz\nax.plot(photon_energies, spectral_fluence / J_per_photon  * 1e-6)\nax.set_xlabel('photon energy (eV)')\nax.set_ylabel(r'spectral intensity (photons/mm$^2$/eV)')\n</pre> fig, ax = plt.subplots() J_per_photon = (h*(freqs + f0)*e) # note h is in eV/Hz ax.plot(photon_energies, spectral_fluence / J_per_photon  * 1e-6) ax.set_xlabel('photon energy (eV)') ax.set_ylabel(r'spectral intensity (photons/mm$^2$/eV)') Out[27]: <pre>Text(0, 0.5, 'spectral intensity (photons/mm$^2$/eV)')</pre> In\u00a0[29]: Copied! <pre>field3d = DFL * np.sqrt(2*Z0) / \u0394 # Electric field\n#field3d = np.pad(field3d, 100, constant_values = 0) #Pad\nnx, ny, nz = field3d.shape\ndx, dy, dz = \u0394, \u0394, ds\nnx, ny, nz, dx, dy, dz\n\n# reciprocal spacings\ndkx, dky, dkz = 1/(nx * dx), 1/(ny * dy), 1/(nz * dz)\n</pre> field3d = DFL * np.sqrt(2*Z0) / \u0394 # Electric field #field3d = np.pad(field3d, 100, constant_values = 0) #Pad nx, ny, nz = field3d.shape dx, dy, dz = \u0394, \u0394, ds nx, ny, nz, dx, dy, dz  # reciprocal spacings dkx, dky, dkz = 1/(nx * dx), 1/(ny * dy), 1/(nz * dz)  In\u00a0[30]: Copied! <pre>spectrum3d = np.fft.fftshift(np.fft.fftn(field3d)) * dx * dy * dz\n</pre> spectrum3d = np.fft.fftshift(np.fft.fftn(field3d)) * dx * dy * dz In\u00a0[31]: Copied! <pre># Check total energy integral\nnp.sum(np.abs(field3d)**2) * dx * dy * dz * epsilon_0 / 2\n</pre> # Check total energy integral np.sum(np.abs(field3d)**2) * dx * dy * dz * epsilon_0 / 2 Out[31]: <pre>3.498831336172631e-05</pre> In\u00a0[32]: Copied! <pre>np.sum(np.abs(spectrum3d)**2) * dkx * dky * dkz * epsilon_0 / 2\n</pre> np.sum(np.abs(spectrum3d)**2) * dkx * dky * dkz * epsilon_0 / 2 Out[32]: <pre>3.498831336172637e-05</pre> In\u00a0[33]: Copied! <pre>kx = np.fft.fftshift(np.fft.fftfreq(nx, dx))\nky = np.fft.fftshift(np.fft.fftfreq(ny, dy))\nkz = np.fft.fftshift(np.fft.fftfreq(nz, dz))\n</pre> kx = np.fft.fftshift(np.fft.fftfreq(nx, dx)) ky = np.fft.fftshift(np.fft.fftfreq(ny, dy)) kz = np.fft.fftshift(np.fft.fftfreq(nz, dz)) In\u00a0[34]: Copied! <pre>Kx, Ky, Kz = np.meshgrid(kx, ky, kz, indexing = 'ij')\nkz0 = 2*pi / \u03bb0\nKz  = Kz + kz0\n\nK = np.sqrt(Kx**2 + Ky**2 + Kz**2)\nk = K.flatten()\ndEk = np.abs(spectrum3d.flatten())**2 *dkx * dky * dkz * epsilon_0 / 2\n</pre> Kx, Ky, Kz = np.meshgrid(kx, ky, kz, indexing = 'ij') kz0 = 2*pi / \u03bb0 Kz  = Kz + kz0  K = np.sqrt(Kx**2 + Ky**2 + Kz**2) k = K.flatten() dEk = np.abs(spectrum3d.flatten())**2 *dkx * dky * dkz * epsilon_0 / 2 In\u00a0[35]: Copied! <pre>np.sum(dEk)\n</pre> np.sum(dEk)  Out[35]: <pre>3.498831336172607e-05</pre> In\u00a0[37]: Copied! <pre>x = k * c * h / (2*pi) # eV\nw = dEk\nbins = 1000\n\nhist, bin_edges = np.histogram(x, bins=bins, weights=w)\nhist_x = bin_edges[:-1] + np.diff(bin_edges) / 2\nhist_width =  np.diff(bin_edges)\n\nhist_y = hist/hist_width\n#hist_y, hist_f, hist_prefix = nice_array(hist/hist_width)\n\nfig, ax = plt.subplots()\nax.bar(hist_x, hist_y*1e6, hist_width, color='gray')\n\nax2 = ax.twinx()\nax2.plot(hist_x, np.cumsum(hist) * 1e6)\nax2.set_ylabel('cumulative energy (\u00b5J)')\nax2.set_ylim(0, None)\n\nax.set_xlabel('photon energy (eV)')\nax.set_ylabel('spectral energy (\u00b5J/eV)')\n</pre> x = k * c * h / (2*pi) # eV w = dEk bins = 1000  hist, bin_edges = np.histogram(x, bins=bins, weights=w) hist_x = bin_edges[:-1] + np.diff(bin_edges) / 2 hist_width =  np.diff(bin_edges)  hist_y = hist/hist_width #hist_y, hist_f, hist_prefix = nice_array(hist/hist_width)  fig, ax = plt.subplots() ax.bar(hist_x, hist_y*1e6, hist_width, color='gray')  ax2 = ax.twinx() ax2.plot(hist_x, np.cumsum(hist) * 1e6) ax2.set_ylabel('cumulative energy (\u00b5J)') ax2.set_ylim(0, None)  ax.set_xlabel('photon energy (eV)') ax.set_ylabel('spectral energy (\u00b5J/eV)') Out[37]: <pre>Text(0, 0.5, 'spectral energy (\u00b5J/eV)')</pre> In\u00a0[38]: Copied! <pre>from genesis.version4 import readers\nimport h5py\n</pre> from genesis.version4 import readers import h5py In\u00a0[39]: Copied! <pre>FILE = G.output['field_files'][0]\nFILE\n</pre> FILE = G.output['field_files'][0] FILE Out[39]: <pre>'/var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpxil8051c/end.fld.h5'</pre> In\u00a0[40]: Copied! <pre>h5py.is_hdf5(FILE)\n</pre> h5py.is_hdf5(FILE) Out[40]: <pre>True</pre> In\u00a0[41]: Copied! <pre>with h5py.File(FILE, 'r') as h5:\n    DFL, PARAM = readers.load_genesis4_fields(h5)\n</pre> with h5py.File(FILE, 'r') as h5:     DFL, PARAM = readers.load_genesis4_fields(h5) In\u00a0[42]: Copied! <pre>DFL.shape, DFL.dtype, PARAM\n</pre> DFL.shape, DFL.dtype, PARAM Out[42]: <pre>((101, 101, 5440),\n dtype('complex128'),\n {'gridpoints': 101,\n  'gridsize': 2e-06,\n  'refposition': 0.0,\n  'wavelength': 1.3789244869952112e-10,\n  'slicecount': 5440,\n  'slicespacing': 2.7578489739904224e-09})</pre> In\u00a0[43]: Copied! <pre>from genesis.version4 import writers\nimport numpy as np\n</pre> from genesis.version4 import writers import numpy as np In\u00a0[44]: Copied! <pre>writers.write_openpmd_wavefront('genesis4_wavefront.h5', DFL, PARAM, verbose=True)\n</pre> writers.write_openpmd_wavefront('genesis4_wavefront.h5', DFL, PARAM, verbose=True) <pre>Writing wavefront (dfl data) to file genesis4_wavefront.h5\n</pre> Out[44]: <pre>'genesis4_wavefront.h5'</pre> In\u00a0[45]: Copied! <pre># Read back\nwith h5py.File('genesis4_wavefront.h5', 'r') as h5:\n    print(list(h5['data']['000000']['meshes']))\n    \n    g = h5['data/000000/meshes/electricField']\n    print(dict(g.attrs))\n    \n    # Get \n    E2 = h5['data/000000/meshes/electricField/x'][:]\n</pre>  # Read back with h5py.File('genesis4_wavefront.h5', 'r') as h5:     print(list(h5['data']['000000']['meshes']))          g = h5['data/000000/meshes/electricField']     print(dict(g.attrs))          # Get      E2 = h5['data/000000/meshes/electricField/x'][:]  <pre>['electricField']\n{'axisLabels': array(['x', 'y', 'z'], dtype=object), 'geometry': 'cartesian', 'gridGlobalOffset': array([-1.00000000e-04, -1.00000000e-04, -7.50134921e-06]), 'gridSpacing': array([2.00000000e-06, 2.00000000e-06, 2.75784897e-09]), 'gridUnitDimension': array([[1, 0, 0, 0, 0, 0, 0],\n       [1, 0, 0, 0, 0, 0, 0],\n       [1, 0, 0, 0, 0, 0, 0]]), 'gridUnitSI': array([1., 1., 1.]), 'photonEnergy': 8991.3696944618, 'photonEnergyUnitDimension': array([ 2,  1, -2,  0,  0,  0,  0]), 'photonEnergyUnitSI': 1.602176634e-19, 'timeOffset': 0.0, 'unitDimension': array([ 1,  1, -3, -1,  0,  0,  0])}\n</pre> In\u00a0[46]: Copied! <pre># Data is the same\nnp.all(E2 == DFL)\n</pre> # Data is the same np.all(E2 == DFL) Out[46]: <pre>True</pre> In\u00a0[47]: Copied! <pre># Nicer plotting\nimport matplotlib.pyplot as plt\nimport matplotlib\nmatplotlib.rcParams['figure.figsize'] = (12,8)\n%config InlineBackend.figure_format = 'retina'\n\nimport numpy as np\n</pre> # Nicer plotting import matplotlib.pyplot as plt import matplotlib matplotlib.rcParams['figure.figsize'] = (12,8) %config InlineBackend.figure_format = 'retina'  import numpy as np In\u00a0[48]: Copied! <pre># Sum over y and compute the absolute square \ndat2 = np.sum(np.abs(DFL)**2, axis=1)\n</pre> # Sum over y and compute the absolute square  dat2 = np.sum(np.abs(DFL)**2, axis=1) In\u00a0[49]: Copied! <pre># Plot the center\nplt.imshow(dat2[::,:], aspect='auto')\n\n#plt.axis('off');plt.savefig('../../assets/field.png', bbox_inches='tight')\n</pre> # Plot the center plt.imshow(dat2[::,:], aspect='auto')  #plt.axis('off');plt.savefig('../../assets/field.png', bbox_inches='tight') Out[49]: <pre>&lt;matplotlib.image.AxesImage at 0x12deb3670&gt;</pre> In\u00a0[50]: Copied! <pre>def plot_slice(i=0):\n    \n    dat = np.angle(DFL[:,:,i])\n    \n    dx = PARAM['gridsize']*1e6\n    plt.xlabel('x (\u00b5m)')\n    plt.xlabel('y (\u00b5m)')\n    plt.title(f'Phase for slice {i}')\n    plt.imshow(dat.T, origin='lower', extent=[-dx,dx,-dx,dx])\nplot_slice(i=100)\n</pre> def plot_slice(i=0):          dat = np.angle(DFL[:,:,i])          dx = PARAM['gridsize']*1e6     plt.xlabel('x (\u00b5m)')     plt.xlabel('y (\u00b5m)')     plt.title(f'Phase for slice {i}')     plt.imshow(dat.T, origin='lower', extent=[-dx,dx,-dx,dx]) plot_slice(i=100) In\u00a0[51]: Copied! <pre>from ipywidgets import interact\n</pre> from ipywidgets import interact In\u00a0[52]: Copied! <pre>interact(plot_slice, i=(0,len(DFL[0,0,:])-1, 1))\n</pre> interact(plot_slice, i=(0,len(DFL[0,0,:])-1, 1)) <pre>interactive(children=(IntSlider(value=0, description='i', max=5439), Output()), _dom_classes=('widget-interact\u2026</pre> Out[52]: <pre>&lt;function __main__.plot_slice(i=0)&gt;</pre> In\u00a0[53]: Copied! <pre>!rm genesis4_wavefront.h5\n</pre> !rm genesis4_wavefront.h5"},{"location":"examples/genesis4/genesis4_field/#field-analysis","title":"Field Analysis\u00b6","text":""},{"location":"examples/genesis4/genesis4_field/#create-field-data","title":"Create field data\u00b6","text":""},{"location":"examples/genesis4/genesis4_field/#3d-field-data","title":"3D Field data\u00b6","text":""},{"location":"examples/genesis4/genesis4_field/#field-power","title":"Field power\u00b6","text":"<p>The power array sums over the x and y components of the absolute square of the field data.</p>"},{"location":"examples/genesis4/genesis4_field/#field-energy","title":"Field energy\u00b6","text":"<p>The total field energy is the integral:</p>"},{"location":"examples/genesis4/genesis4_field/#on-axis-field-intensity-and-phase","title":"On-axis field intensity and phase\u00b6","text":""},{"location":"examples/genesis4/genesis4_field/#spectral-fluence","title":"Spectral fluence\u00b6","text":"<p>The spectrum calculation takes some care with the FFT and units.</p>"},{"location":"examples/genesis4/genesis4_field/#3d-fft","title":"3D FFT\u00b6","text":"<p>WORK IN PROGRESS</p>"},{"location":"examples/genesis4/genesis4_field/#field-data-formats","title":"Field data formats\u00b6","text":"<p>Genesis4 writes a custom field format. LUME-Genesis provides a reader for this, as well as a conversion tool to write in the openPMD-wavefront standard.</p>"},{"location":"examples/genesis4/genesis4_field/#read-field-h5","title":"Read Field h5\u00b6","text":""},{"location":"examples/genesis4/genesis4_field/#write-wavefront-in-openpmd-wavefront","title":"Write Wavefront in openPMD-wavefront\u00b6","text":""},{"location":"examples/genesis4/genesis4_field/#plot","title":"Plot\u00b6","text":"<p>Simple plot</p>"},{"location":"examples/genesis4/genesis4_field/#cleanup","title":"Cleanup\u00b6","text":""},{"location":"examples/genesis4/genesis4_parsing/","title":"Genesis4 Parsing","text":"In\u00a0[80]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 <pre>The autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload\n</pre> In\u00a0[81]: Copied! <pre>FILE = '../examples/data/basic4/cu_hxr.in'\n</pre> FILE = '../examples/data/basic4/cu_hxr.in' In\u00a0[82]: Copied! <pre>def expand_path(file, path=None):\n    if not os.path.isabs(file):\n        file = os.path.join(path, file)\n    return tools.full_path(file)\n</pre> def expand_path(file, path=None):     if not os.path.isabs(file):         file = os.path.join(path, file)     return tools.full_path(file) In\u00a0[93]: Copied! <pre>from genesis.version4.parsers import parse_main_input\nMAIN = parse_main_input(FILE)\nMAIN\n</pre> from genesis.version4.parsers import parse_main_input MAIN = parse_main_input(FILE) MAIN Out[93]: <pre>[{'type': 'setup',\n  'rootname': 'LCLS2_HXR_9keV',\n  'lattice': '/Users/chrisonian/Code/GitHub/lume-genesis/examples/data/basic4/hxr.lat',\n  'beamline': 'HXR',\n  'lambda0': 1.3789244869952112e-10,\n  'gamma0': 19174.0776,\n  'delz': 0.026,\n  'seed': 84672,\n  'npart': 1024},\n {'type': 'time', 'slen': 1.5e-05, 'sample': 200},\n {'type': 'field', 'dgrid': 0.0001, 'ngrid': 101, 'accumulate': True},\n {'type': 'profile_file',\n  'label': 'beamcurrent',\n  'xdata': array([0.00000000e+00, 7.50037502e-10, 1.50007500e-09, ...,\n         1.49984999e-05, 1.49992500e-05, 1.50000000e-05]),\n  'ydata': array([2.65147892, 2.65521019, 2.65894633, ..., 2.65894633, 2.65521019,\n         2.65147892])},\n {'type': 'profile_file',\n  'label': 'beamgamma',\n  'xdata': array([0.00000000e+00, 7.50037502e-10, 1.50007500e-09, ...,\n         1.49984999e-05, 1.49992500e-05, 1.50000000e-05]),\n  'ydata': array([19394.23415577, 19394.21213902, 19394.19012226, ...,\n         18953.96507774, 18953.94306098, 18953.92104423])},\n {'type': 'beam',\n  'current': '@beamcurrent',\n  'gamma': '@beamgamma',\n  'delgam': 3.97848,\n  'ex': 4e-07,\n  'ey': 4e-07,\n  'alphax': -0.7393217413918415,\n  'betax': 7.910909406464387,\n  'alphay': 1.3870723536888105,\n  'betay': 16.881178621346898},\n {'type': 'track', 'field_dump_at_undexit': False, 'zstop': 10}]</pre> In\u00a0[100]: Copied! <pre>\n</pre> In\u00a0[97]: Copied! <pre>def write_profile_files(profile_dict, path):\n    file = os.path.join(path, profile_dict['label']+'.h5')\n    with h5py.File(file, 'w') as h5:\n        for k in ['xdata', 'ydata']:\n            h5[k] = profile_dict[k]\nwrite_profile_files(MAIN[4], 'test/')\n</pre> def write_profile_files(profile_dict, path):     file = os.path.join(path, profile_dict['label']+'.h5')     with h5py.File(file, 'w') as h5:         for k in ['xdata', 'ydata']:             h5[k] = profile_dict[k] write_profile_files(MAIN[4], 'test/') In\u00a0[98]: Copied! <pre>!ls test\n</pre> !ls test <pre>beamgamma.h5\n</pre> In\u00a0[\u00a0]: Copied! <pre>def expand_paths(main_list):\n    for d in main_list:\n        if d['type']\n</pre>   def expand_paths(main_list):     for d in main_list:         if d['type']  In\u00a0[30]: Copied! <pre>from lume.parsers.namelist import namelist_lines\nfrom lume.tools import full_path\nimport shutil\nimport os\n</pre> from lume.parsers.namelist import namelist_lines from lume.tools import full_path import shutil import os In\u00a0[31]: Copied! <pre>with open('test.in', 'w') as f:\n    for d in MAIN:\n        d = d.copy()\n        name = d.pop('type')\n        f.write('\\n')\n        lines = namelist_lines(d, name, end='&amp;end', strip_strings=True)\n        for line in lines:\n            f.write(line+'\\n')\n</pre> with open('test.in', 'w') as f:     for d in MAIN:         d = d.copy()         name = d.pop('type')         f.write('\\n')         lines = namelist_lines(d, name, end='&amp;end', strip_strings=True)         for line in lines:             f.write(line+'\\n') In\u00a0[27]: Copied! <pre>FILEKEYS = ['lattice']\n\nfor d in MAIN:\n    for k in d:\n        if k not in FILEKEYS:\n            continue\n        file = full_path(d[k])\n        assert os.path.exists(file), file\n        print(v)\n</pre> FILEKEYS = ['lattice']  for d in MAIN:     for k in d:         if k not in FILEKEYS:             continue         file = full_path(d[k])         assert os.path.exists(file), file         print(v)  <pre>\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nCell In[27], line 8\n      6     continue\n      7 file = full_path(d[k])\n----&gt; 8 assert os.path.exists(file), file\n      9 print(v)\n\nAssertionError: /Users/chrisonian/Code/GitHub/lume-genesis/examples/hxr.lat</pre> In\u00a0[23]: Copied! <pre>os.path.split('/afafa/faaf/afafa/fafa')\n</pre> os.path.split('/afafa/faaf/afafa/fafa') Out[23]: <pre>('/afafa/faaf/afafa', 'fafa')</pre> In\u00a0[\u00a0]: Copied! <pre>!cat test.in\n</pre> !cat test.in In\u00a0[\u00a0]: Copied! <pre>LINES = parse_simple_namelist(FILE)\nNAMES, DICTS = parse_unrolled_namelist(LINES, end='&amp;end')\n</pre> LINES = parse_simple_namelist(FILE) NAMES, DICTS = parse_unrolled_namelist(LINES, end='&amp;end') In\u00a0[\u00a0]: Copied! <pre>!mkdir test\n</pre> !mkdir test In\u00a0[90]: Copied! <pre>import h5py\nimport os\nimport numpy as np\n\nfrom genesis.version4.parsers import parse_genesis4_h5filegroup\n</pre> import h5py import os import numpy as np  from genesis.version4.parsers import parse_genesis4_h5filegroup In\u00a0[39]: Copied! <pre>with h5py.File('test.h5', 'w') as h5:\n    h5['x'] = [1,2,3]\n    h5.create_group('g1')\n    h5['g1']['y'] = [3,4,5]\n</pre> with h5py.File('test.h5', 'w') as h5:     h5['x'] = [1,2,3]     h5.create_group('g1')     h5['g1']['y'] = [3,4,5] In\u00a0[41]: Copied! <pre>with h5py.File('test.h5', 'r') as h5:\n    print(h5['x'])\n    print(h5['g1/y'])\n</pre> with h5py.File('test.h5', 'r') as h5:     print(h5['x'])     print(h5['g1/y']) <pre>&lt;HDF5 dataset \"x\": shape (3,), type \"&lt;i8\"&gt;\n&lt;HDF5 dataset \"y\": shape (3,), type \"&lt;i8\"&gt;\n</pre> In\u00a0[45]: Copied! <pre>os.path.isabs('/fafa/')\n</pre> os.path.isabs('/fafa/') Out[45]: <pre>True</pre> In\u00a0[86]: Copied! <pre>H5G = '/Users/chrisonian/Code/GitHub/lume-genesis/examples/data/basic4/beam_gamma.h5/s'\nparse_genesis4_h5filegroup(H5G)\n</pre> H5G = '/Users/chrisonian/Code/GitHub/lume-genesis/examples/data/basic4/beam_gamma.h5/s' parse_genesis4_h5filegroup(H5G) Out[86]: <pre>('///Users/chrisonian/Code/GitHub/lume-genesis/examples/data/basic4/beam_gamma.h5',\n 's')</pre> In\u00a0[92]: Copied! <pre>def load_genesis4_h5filegroup(filegroup, path=None):\n    file, group = parse_genesis4_h5filegroup(filegroup, path=path)\n    with h5py.File(file) as h5:\n        data = h5[group][:]\n    return data\nload_genesis4_h5filegroup(H5G)\n</pre> def load_genesis4_h5filegroup(filegroup, path=None):     file, group = parse_genesis4_h5filegroup(filegroup, path=path)     with h5py.File(file) as h5:         data = h5[group][:]     return data load_genesis4_h5filegroup(H5G) Out[92]: <pre>array([0.00000000e+00, 7.50037502e-10, 1.50007500e-09, ...,\n       1.49984999e-05, 1.49992500e-05, 1.50000000e-05])</pre> In\u00a0[\u00a0]: Copied! <pre>def expand_paths(main_list):\n    for d in main_list:\n        if d['type'] == 'profile_file':\n</pre> def expand_paths(main_list):     for d in main_list:         if d['type'] == 'profile_file':                   In\u00a0[46]: Copied! <pre>\n</pre> In\u00a0[42]: Copied! <pre>with h5py.File('test.h5/g1', 'r') as h5:\n    print(h5['y'])\n</pre> with h5py.File('test.h5/g1', 'r') as h5:     print(h5['y']) <pre>\n---------------------------------------------------------------------------\nNotADirectoryError                        Traceback (most recent call last)\nCell In[42], line 1\n----&gt; 1 with h5py.File('test.h5/g1', 'r') as h5:\n      2     print(h5['y'])\n\nFile ~/Code/mambaforge/envs/devel/lib/python3.9/site-packages/h5py/_hl/files.py:567, in File.__init__(self, name, mode, driver, libver, userblock_size, swmr, rdcc_nslots, rdcc_nbytes, rdcc_w0, track_order, fs_strategy, fs_persist, fs_threshold, fs_page_size, page_buf_size, min_meta_keep, min_raw_keep, locking, alignment_threshold, alignment_interval, meta_block_size, **kwds)\n    558     fapl = make_fapl(driver, libver, rdcc_nslots, rdcc_nbytes, rdcc_w0,\n    559                      locking, page_buf_size, min_meta_keep, min_raw_keep,\n    560                      alignment_threshold=alignment_threshold,\n    561                      alignment_interval=alignment_interval,\n    562                      meta_block_size=meta_block_size,\n    563                      **kwds)\n    564     fcpl = make_fcpl(track_order=track_order, fs_strategy=fs_strategy,\n    565                      fs_persist=fs_persist, fs_threshold=fs_threshold,\n    566                      fs_page_size=fs_page_size)\n--&gt; 567     fid = make_fid(name, mode, userblock_size, fapl, fcpl, swmr=swmr)\n    569 if isinstance(libver, tuple):\n    570     self._libver = libver\n\nFile ~/Code/mambaforge/envs/devel/lib/python3.9/site-packages/h5py/_hl/files.py:231, in make_fid(name, mode, userblock_size, fapl, fcpl, swmr)\n    229     if swmr and swmr_support:\n    230         flags |= h5f.ACC_SWMR_READ\n--&gt; 231     fid = h5f.open(name, flags, fapl=fapl)\n    232 elif mode == 'r+':\n    233     fid = h5f.open(name, h5f.ACC_RDWR, fapl=fapl)\n\nFile h5py/_objects.pyx:54, in h5py._objects.with_phil.wrapper()\n\nFile h5py/_objects.pyx:55, in h5py._objects.with_phil.wrapper()\n\nFile h5py/h5f.pyx:106, in h5py.h5f.open()\n\nNotADirectoryError: [Errno 20] Unable to synchronously open file (unable to open file: name = 'test.h5/g1', errno = 20, error message = 'Not a directory', flags = 0, o_flags = 0)</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/genesis4/genesis4_parsing/#genesis4-parsing","title":"Genesis4 Parsing\u00b6","text":""},{"location":"examples/genesis4/genesis4_parsing/#h5-files","title":"H5 files\u00b6","text":""},{"location":"examples/genesis4/genesis4_particles/","title":"Genesis4 Particles","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>from genesis.version4 import Genesis4\nfrom lume.tools import full_path\nimport os\nimport numpy as np\nfrom scipy.constants import c\nfrom math import sqrt, pi\nimport matplotlib.pyplot as plt\n%config InlineBackend.figure_format = 'retina'\n</pre> from genesis.version4 import Genesis4 from lume.tools import full_path import os import numpy as np from scipy.constants import c from math import sqrt, pi import matplotlib.pyplot as plt %config InlineBackend.figure_format = 'retina' In\u00a0[3]: Copied! <pre>LATFILE = 'data/genesis4_drift.lat'\n\ndef make_lat():\n    lat = f\"\"\"\nD1: DRIFT = {{ l = 1}};\nLAT: LINE= {{ D1 }};\n    \"\"\"\n    with open(LATFILE, 'w') as f:\n        f.write(lat)\n    \nmake_lat()\n!cat {LATFILE}\n</pre> LATFILE = 'data/genesis4_drift.lat'  def make_lat():     lat = f\"\"\" D1: DRIFT = {{ l = 1}}; LAT: LINE= {{ D1 }};     \"\"\"     with open(LATFILE, 'w') as f:         f.write(lat)      make_lat() !cat {LATFILE} <pre>\nD1: DRIFT = { l = 1};\nLAT: LINE= { D1 };\n    </pre> In\u00a0[4]: Copied! <pre>PEAK_CURRENT = 1000\nBUNCH_CHARGE = 100e-12\nSIGMA_T = BUNCH_CHARGE / (sqrt(2*pi) * PEAK_CURRENT)\nSIGMA_Z = SIGMA_T * c\nSLEN = 6*SIGMA_Z\nS0 = 3*SIGMA_Z\nSIGMA_T, SIGMA_Z, SLEN\n</pre> PEAK_CURRENT = 1000 BUNCH_CHARGE = 100e-12 SIGMA_T = BUNCH_CHARGE / (sqrt(2*pi) * PEAK_CURRENT) SIGMA_Z = SIGMA_T * c SLEN = 6*SIGMA_Z S0 = 3*SIGMA_Z SIGMA_T, SIGMA_Z, SLEN Out[4]: <pre>(3.989422804014327e-14, 1.1959988684167075e-05, 7.175993210500245e-05)</pre> In\u00a0[5]: Copied! <pre>G = Genesis4()\n\nINPUT0 = {'main': [{'type': 'setup',\n   'rootname': 'drift_test',\n   'lattice': full_path(LATFILE),\n   'beamline': 'LAT',\n   'lambda0': 100e-9,\n   'gamma0': 1000,\n   'delz': 0.026,\n   'seed': 123456,\n   'npart': 128},\n  {'type': 'time', 'slen': SLEN, 'sample': 1},\n  {'type': 'profile_gauss',\n   'label': 'beamcurrent',\n   'c0': PEAK_CURRENT,\n   's0': S0,\n   'sig': SIGMA_Z},\n  {'type': 'beam',\n   'current': '@beamcurrent',\n   'gamma': 1000,\n   'delgam': 1,\n  },\n  {'type': 'track', 'zstop': 1},\n  {'type':'write', 'beam':'end'},\n                  ]}\n\nG.input = INPUT0\nG.verbose=True\nG.run()\n</pre> G = Genesis4()  INPUT0 = {'main': [{'type': 'setup',    'rootname': 'drift_test',    'lattice': full_path(LATFILE),    'beamline': 'LAT',    'lambda0': 100e-9,    'gamma0': 1000,    'delz': 0.026,    'seed': 123456,    'npart': 128},   {'type': 'time', 'slen': SLEN, 'sample': 1},   {'type': 'profile_gauss',    'label': 'beamcurrent',    'c0': PEAK_CURRENT,    's0': S0,    'sig': SIGMA_Z},   {'type': 'beam',    'current': '@beamcurrent',    'gamma': 1000,    'delgam': 1,   },   {'type': 'track', 'zstop': 1},   {'type':'write', 'beam':'end'},                   ]}  G.input = INPUT0 G.verbose=True G.run() <pre>Configured to run in: /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpsb0wz0u_\nRunning Genesis4 in /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpsb0wz0u_\n/Users/chrisonian/Code/GitHub/Genesis-1.3-Version4/build/genesis4 genesis4.in\n---------------------------------------------\nGENESIS - Version 4.6.2 (beta) has started...\nCompile info: Compiled by chrisonian at 2023-03-29 01:26:27 [UTC] from Git Commit ID: 659546c43d06d196c800130a241cfee9ba6deead\nStarting Time: Wed Mar 29 12:43:14 2023\n\nMPI-Comm Size: 1 node\n\nParsing lattice file...\nSetting up time window of 71.8 microns with 718 sample points...\nAdding profile with label: beamcurrent\nGenerating input particle distribution...\n\nRunning Core Simulation...\nTime-dependent run with 718 slices for a time window of 71.8 microns\nInitial analysis of electron beam and radiation field...\nWriting output file...\n\nCore Simulation done.\nEnd of Track\nWriting particle distribution to file: end.par.h5 ...\n\nProgram is terminating...\nEnding Time: Wed Mar 29 12:43:14 2023\nTotal Wall Clock Time: 0.118107 seconds\n-------------------------------------\nFinished.\nLoading main output: /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpsb0wz0u_/drift_test.out.h5\n</pre> In\u00a0[6]: Copied! <pre>G.load_particles()\nP1 = G.particles['end']\nP1.drift_to_z()\nP1.plot('t', 'energy')\nP1\n</pre> G.load_particles() P1 = G.particles['end'] P1.drift_to_z() P1.plot('t', 'energy') P1 <pre>Loaded particle data: 'end' as a ParticleGroup with 91904 particles\n</pre> Out[6]: <pre>&lt;ParticleGroup with 91904 particles at 0x107e33a00&gt;</pre> <p>Check the charge</p> In\u00a0[7]: Copied! <pre>P1.charge\n</pre> P1.charge Out[7]: <pre>9.973150081144012e-11</pre> <p>LUME-Genesis automatically makes an HDF5 file from the arrays in the <code>profile_file</code> namelist. The user just needs to provide these in the dict in place of the filename.</p> In\u00a0[8]: Copied! <pre>NPTS = 100\nSLEN = 100e-6 \nS = np.linspace(0, SLEN, NPTS)\nCURRENT = np.linspace(1, 1000.0, NPTS)\nplt.plot(S, CURRENT)\n</pre> NPTS = 100 SLEN = 100e-6  S = np.linspace(0, SLEN, NPTS) CURRENT = np.linspace(1, 1000.0, NPTS) plt.plot(S, CURRENT) Out[8]: <pre>[&lt;matplotlib.lines.Line2D at 0x129866040&gt;]</pre> In\u00a0[9]: Copied! <pre>G = Genesis4()\n\nINPUT0 = {'main': [{'type': 'setup',\n   'rootname': 'drift_test',\n   'lattice': full_path(LATFILE),\n   'beamline': 'LAT',\n   'lambda0': 100e-9,\n   'gamma0': 1000,\n   'delz': 0.026,\n   'seed': 123456,\n   'npart': 128},\n  {'type': 'time', 'slen': SLEN, 'sample': 1},\n # {'type': 'field', 'dgrid': 0.0001, 'ngrid': 101, 'accumulate': True},\n  {'type': 'profile_file',\n   'label': 'beamcurrent',\n   'xdata': S, \n   'ydata': CURRENT},\n  {'type': 'beam',\n   'current': '@beamcurrent',\n   'gamma': 1000,\n   'delgam': 1,\n   'ex': 1e-6,\n   'ey': 1e-6,\n   'alphax': -0.7393217413918415,\n   'betax': 7.910909406464387,\n   'alphay': 1.3870723536888105,\n   'betay': 16.881178621346898},\n  {'type': 'track', 'zstop': 1},\n  {'type':'write', 'beam':'end'},\n                  ]}\n\nG.input = INPUT0\nG.verbose=True\nG.run()\n</pre> G = Genesis4()  INPUT0 = {'main': [{'type': 'setup',    'rootname': 'drift_test',    'lattice': full_path(LATFILE),    'beamline': 'LAT',    'lambda0': 100e-9,    'gamma0': 1000,    'delz': 0.026,    'seed': 123456,    'npart': 128},   {'type': 'time', 'slen': SLEN, 'sample': 1},  # {'type': 'field', 'dgrid': 0.0001, 'ngrid': 101, 'accumulate': True},   {'type': 'profile_file',    'label': 'beamcurrent',    'xdata': S,     'ydata': CURRENT},   {'type': 'beam',    'current': '@beamcurrent',    'gamma': 1000,    'delgam': 1,    'ex': 1e-6,    'ey': 1e-6,    'alphax': -0.7393217413918415,    'betax': 7.910909406464387,    'alphay': 1.3870723536888105,    'betay': 16.881178621346898},   {'type': 'track', 'zstop': 1},   {'type':'write', 'beam':'end'},                   ]}  G.input = INPUT0 G.verbose=True G.run() <pre>Configured to run in: /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp144iog86\nRunning Genesis4 in /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp144iog86\n/Users/chrisonian/Code/GitHub/Genesis-1.3-Version4/build/genesis4 genesis4.in\n---------------------------------------------\nGENESIS - Version 4.6.2 (beta) has started...\nCompile info: Compiled by chrisonian at 2023-03-29 01:26:27 [UTC] from Git Commit ID: 659546c43d06d196c800130a241cfee9ba6deead\nStarting Time: Wed Mar 29 12:43:16 2023\n\nMPI-Comm Size: 1 node\n\nParsing lattice file...\nSetting up time window of 100 microns with 1000 sample points...\nAdding profile with label: beamcurrent\nGenerating input particle distribution...\n\nRunning Core Simulation...\nTime-dependent run with 1000 slices for a time window of 100 microns\nInitial analysis of electron beam and radiation field...\nWriting output file...\n\nCore Simulation done.\nEnd of Track\nWriting particle distribution to file: end.par.h5 ...\n\nProgram is terminating...\nEnding Time: Wed Mar 29 12:43:16 2023\nTotal Wall Clock Time: 0.169426 seconds\n-------------------------------------\nFinished.\nLoading main output: /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmp144iog86/drift_test.out.h5\n</pre> In\u00a0[10]: Copied! <pre>G.load_particles()\nP1 = G.particles['end']\nP1.drift_to_z()\nP1.plot('t', 'energy')\nP1\n</pre> G.load_particles() P1 = G.particles['end'] P1.drift_to_z() P1.plot('t', 'energy') P1 <pre>Loaded particle data: 'end' as a ParticleGroup with 128000 particles\n</pre> Out[10]: <pre>&lt;ParticleGroup with 128000 particles at 0x12989e670&gt;</pre> <p>Resample particles for equal weights. This is neccessary when reading from a distribution file.</p> In\u00a0[11]: Copied! <pre>NSAMPLE = len(P1)\nP1r = P1.resample(NSAMPLE)\nP1r.plot('t', 'energy')\nP1r\n</pre> NSAMPLE = len(P1) P1r = P1.resample(NSAMPLE) P1r.plot('t', 'energy') P1r Out[11]: <pre>&lt;ParticleGroup with 128000 particles at 0x129fb7e20&gt;</pre> <p>Make a more interesting distribution from this:</p> In\u00a0[12]: Copied! <pre>P1r.pz[0:len(P1)//2] *= 1.1\nP1r.plot('t', 'energy')\n</pre> P1r.pz[0:len(P1)//2] *= 1.1 P1r.plot('t', 'energy') <p>ParticleGroup can write to a file for Genesis4.</p> In\u00a0[13]: Copied! <pre>DIST_FILE = 'genesis4_distribution.h5'\nP1r.write_genesis4_distribution(DIST_FILE, verbose=True)\n</pre> DIST_FILE = 'genesis4_distribution.h5' P1r.write_genesis4_distribution(DIST_FILE, verbose=True) <pre>Datasets x, xp, y, yp, t, p written to: genesis4_distribution.h5\n</pre> In\u00a0[14]: Copied! <pre>G1 = Genesis4()\n\nINPUT1 = {'main': [{'type': 'setup',\n   'rootname': 'drift_test',\n   'lattice': full_path(LATFILE),\n   'beamline': 'LAT',\n   'lambda0': 100e-9,\n   'gamma0': 1000,\n   'delz': 0.026,\n   'seed': 123456,\n   'npart': 128*4},\n  {'type': 'time', 'slen': SLEN, 'sample': 1},\n#  {'type': 'field', 'dgrid': 0.0001, 'ngrid': 101, 'accumulate': True},\n  {'type': 'track', 'zstop': 1},\n  {'type':'write', 'beam':'end'},\n                  ]}\n\nG1.input = INPUT1\nG1.verbose=True\nG1.initial_particles = P1r\nG1.run()\n</pre> G1 = Genesis4()  INPUT1 = {'main': [{'type': 'setup',    'rootname': 'drift_test',    'lattice': full_path(LATFILE),    'beamline': 'LAT',    'lambda0': 100e-9,    'gamma0': 1000,    'delz': 0.026,    'seed': 123456,    'npart': 128*4},   {'type': 'time', 'slen': SLEN, 'sample': 1}, #  {'type': 'field', 'dgrid': 0.0001, 'ngrid': 101, 'accumulate': True},   {'type': 'track', 'zstop': 1},   {'type':'write', 'beam':'end'},                   ]}  G1.input = INPUT1 G1.verbose=True G1.initial_particles = P1r G1.run() <pre>Configured to run in: /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpey80t6g8\nRunning Genesis4 in /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpey80t6g8\n/Users/chrisonian/Code/GitHub/Genesis-1.3-Version4/build/genesis4 genesis4.in\nInitial particles written to /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpey80t6g8/genesis4_importdistribution.h5\nAdded new importdistribution before track\n---------------------------------------------\nGENESIS - Version 4.6.2 (beta) has started...\nCompile info: Compiled by chrisonian at 2023-03-29 01:26:27 [UTC] from Git Commit ID: 659546c43d06d196c800130a241cfee9ba6deead\nStarting Time: Wed Mar 29 12:43:30 2023\n\nMPI-Comm Size: 1 node\n\nParsing lattice file...\nSetting up time window of 100 microns with 1000 sample points...\nImporting distribution file... \nCharge of external distribution: 1.66782e-10\nParticles in external distribution: 128000\nAnalysing external distribution... \nAnalysis of the imported distribution\n   Total Bunch Length  (microns): 99.6095\n   Length for Matching (microns): 99.6095\n   Energy                  (MeV): 536.551\n   Norm. Emittance in x (micron): 1.00331\n   Norm. Emittance in y (micron): 0.997669\n   Beta Function in x        (m): 9.9742\n   Beta Function in y        (m): 15.0207\n   Alpha Function in x          : -0.924334\n   Alpha Function in y          : 1.21335\n   Beam center in x     (micron): 0.106518\n   Beam center in y     (micron): 0.255781\n   Beam center in px            : 4.86545e-08\n   Beam center in py            : -1.98248e-08\nSorting external distribution...\nGlobal Sorting: Slicelength: 0 - Send backwards for theta &lt; 4.98048e-07 - Send forward for theta &gt; 9.9402e-05\n*** Non-matching PArticle Transfar: Rank: 0 Deleted: 0 Forward: 486 Backward: 11\nGenerating internal particle distribution...\n\nRunning Core Simulation...\nTime-dependent run with 1000 slices for a time window of 100 microns\nInitial analysis of electron beam and radiation field...\nWriting output file...\n\nCore Simulation done.\nEnd of Track\nWriting particle distribution to file: end.par.h5 ...\n\nProgram is terminating...\nEnding Time: Wed Mar 29 12:43:31 2023\nTotal Wall Clock Time: 0.367443 seconds\n-------------------------------------\nFinished.\nLoading main output: /var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpey80t6g8/drift_test.out.h5\n</pre> In\u00a0[15]: Copied! <pre>G1.load_particles()\nP2 = G1.particles['end']\nP2.z\n</pre> G1.load_particles() P2 = G1.particles['end'] P2.z <pre>Loaded particle data: 'end' as a ParticleGroup with 512000 particles\n</pre> Out[15]: <pre>array([1.63786104e-08, 4.62092158e-08, 7.56749909e-08, ...,\n       9.99397535e-05, 9.99644023e-05, 9.99896312e-05])</pre> In\u00a0[16]: Copied! <pre>P2.drift_to_z()\nP2.plot('t', 'energy')\nP2\n</pre> P2.drift_to_z() P2.plot('t', 'energy') P2 Out[16]: <pre>&lt;ParticleGroup with 512000 particles at 0x1292ef9d0&gt;</pre> In\u00a0[17]: Copied! <pre>P2.plot('weight', bins=100)\n</pre> P2.plot('weight', bins=100) <p>Notice that <code>importdistribution</code> is filled in:</p> In\u00a0[18]: Copied! <pre>G1.input\n</pre> G1.input Out[18]: <pre>{'main': [{'type': 'setup',\n   'rootname': 'drift_test',\n   'lattice': '/Users/chrisonian/Code/GitHub/lume-genesis/docs/examples/genesis4/data/genesis4_drift.lat',\n   'beamline': 'LAT',\n   'lambda0': 1e-07,\n   'gamma0': 1000,\n   'delz': 0.026,\n   'seed': 123456,\n   'npart': 512},\n  {'type': 'time', 'slen': 0.0001, 'sample': 1},\n  {'type': 'importdistribution',\n   'file': '/var/folders/2f/l5_mybzs30j4qqvyj98w1_nw0000gn/T/tmpey80t6g8/genesis4_importdistribution.h5',\n   'charge': 1.667822143811237e-10},\n  {'type': 'track', 'zstop': 1},\n  {'type': 'write', 'beam': 'end'}]}</pre>"},{"location":"examples/genesis4/genesis4_particles/#genesis4-particles","title":"Genesis4 Particles\u00b6","text":"<p>This shows examples of the various ways to input particle data into Genesis4.</p>"},{"location":"examples/genesis4/genesis4_particles/#lattice","title":"Lattice\u00b6","text":"<p>Create a simple drift lattice</p>"},{"location":"examples/genesis4/genesis4_particles/#profile_gauss","title":"<code>profile_gauss</code>\u00b6","text":"<p>This profile will make a Gaussian distribition. Here we do some calculations to make the correct bunch length for a given bunch charge to provide a peak current.</p>"},{"location":"examples/genesis4/genesis4_particles/#profile_file","title":"<code>profile_file</code>\u00b6","text":""},{"location":"examples/genesis4/genesis4_particles/#importdistribution","title":"importdistribution\u00b6","text":"<p>Use this file as the input to a new simulation.</p> <p>When using <code>.initial_particles</code>, the appropriate input will be written automatically.</p>"},{"location":"examples/genesis4/perlmutter_benchmark/","title":"Genesis4 Benchmark on Perlmutter (NERSC)","text":"In\u00a0[1]: Copied! <pre>from genesis.version4 import Genesis4\nimport os\n</pre> from genesis.version4 import Genesis4 import os <p>The <code>MPI_RUN</code> class attribute needs to be replaced. For convenience, Genesis4 tries to detect NERSC:</p> In\u00a0[2]: Copied! <pre>Genesis4.MPI_RUN\n</pre> Genesis4.MPI_RUN Out[2]: <pre>'srun -n {nproc} --ntasks-per-node {nproc} -c 1 {command_mpi}'</pre> <p>Additionally, the working directory must be on the scratch disk. This is automatically detected:</p> In\u00a0[3]: Copied! <pre>Genesis4.WORKDIR\n</pre> Genesis4.WORKDIR Out[3]: <pre>'/pscratch/sd/c/cmayes'</pre> <p>Create Genesis4 object:</p> In\u00a0[4]: Copied! <pre>FILE = 'data/basic4/cu_hxr.in'\nG = Genesis4(FILE)\n</pre> FILE = 'data/basic4/cu_hxr.in' G = Genesis4(FILE) <p>Set up the benchmark</p> In\u00a0[5]: Copied! <pre>G.input['main'][6]['zstop'] = 40\n</pre> G.input['main'][6]['zstop'] = 40 <p>Run with MPI</p> In\u00a0[6]: Copied! <pre>%%time\nG.verbose=False\nG.nproc = 128\nG.run()\n</pre> %%time G.verbose=False G.nproc = 128 G.run() <pre>CPU times: user 15.7 ms, sys: 79.2 ms, total: 94.9 ms\nWall time: 8.62 s\n</pre> In\u00a0[7]: Copied! <pre>MAX_CPUS = os.cpu_count()\nCPUS_PER_NODE = 128\nMIN_CPUS = MAX_CPUS // 8\nMAX_CPUS, MIN_CPUS\n</pre> MAX_CPUS = os.cpu_count() CPUS_PER_NODE = 128 MIN_CPUS = MAX_CPUS // 8 MAX_CPUS, MIN_CPUS Out[7]: <pre>(256, 32)</pre> In\u00a0[8]: Copied! <pre>def time1(nproc):\n    G.verbose=False\n    G.nproc = nproc\n    G.nnode = (nproc -1)// CPUS_PER_NODE + 1\n    G.run()\n    dt = G.output['run_info']['run_time']\n    return dt\n\ntime1(MAX_CPUS)\n</pre> def time1(nproc):     G.verbose=False     G.nproc = nproc     G.nnode = (nproc -1)// CPUS_PER_NODE + 1     G.run()     dt = G.output['run_info']['run_time']     return dt  time1(MAX_CPUS) Out[8]: <pre>11.547049283981323</pre> In\u00a0[9]: Copied! <pre>%%time\nnlist = []\ntlist = []\nn_cpu = MAX_CPUS\nwhile n_cpu &gt; 0:\n    n = n_cpu\n    if n &lt; MIN_CPUS:\n        break\n    nlist.append(n)\n    dt = time1(n)\n    tlist.append(dt)\n    print(f'{n} cores, {dt:0.1f} s')\n    n_cpu = n_cpu //2\n</pre> %%time nlist = [] tlist = [] n_cpu = MAX_CPUS while n_cpu &gt; 0:     n = n_cpu     if n &lt; MIN_CPUS:         break     nlist.append(n)     dt = time1(n)     tlist.append(dt)     print(f'{n} cores, {dt:0.1f} s')     n_cpu = n_cpu //2 <pre>256 cores, 12.2 s\n128 cores, 8.7 s\n64 cores, 15.5 s\n32 cores, 28.2 s\nCPU times: user 137 ms, sys: 239 ms, total: 375 ms\nWall time: 1min 4s\n</pre> In\u00a0[10]: Copied! <pre>nlist, tlist\n</pre> nlist, tlist Out[10]: <pre>([256, 128, 64, 32],\n [12.181392192840576,\n  8.661577463150024,\n  15.486478090286255,\n  28.164244413375854])</pre> In\u00a0[11]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n%config InlineBackend.figure_format = 'retina'\n\n# Perlmutter\nnlist, tlist =([256, 128, 64, 32, 16, 8, 4, 2, 1],\n [12.407618761062622,\n  9.337806940078735,\n  15.55810832977295,\n  27.734387397766113,\n  49.104663372039795,\n  113.33639931678772,\n  184.2123155593872,\n  367.3742334842682,\n  555.4603695869446])\nnlist = np.array(nlist)[::-1]\ntlist = np.array(tlist)[::-1]\n\ntref = tlist[0]\n\n# M1 Max \nnlistmac, tlistmac =([8, 4, 2, 1],\n [38.151074171066284,\n  75.41113114356995,\n  146.3512842655182,\n  285.11587405204773])\nnlistmac = np.array(nlistmac)\ntlistmac = np.array(tlistmac)\n\n\n\nplt.plot(nlist, tlist/tref, marker='.', label='Genesis4 Perlmutter')\nplt.plot(nlistmac, tlistmac/tref,  marker='.', label='Genesis4 M1 Max')\nplt.plot(nlist,  1/(nlist/nlist[0]), '--', label='ideal')\nplt.xscale('log')\nplt.yscale('log')\nplt.xlabel('n cores')\nplt.ylabel('run time (normalized)')\nplt.legend()\n</pre> import numpy as np import matplotlib.pyplot as plt %config InlineBackend.figure_format = 'retina'  # Perlmutter nlist, tlist =([256, 128, 64, 32, 16, 8, 4, 2, 1],  [12.407618761062622,   9.337806940078735,   15.55810832977295,   27.734387397766113,   49.104663372039795,   113.33639931678772,   184.2123155593872,   367.3742334842682,   555.4603695869446]) nlist = np.array(nlist)[::-1] tlist = np.array(tlist)[::-1]  tref = tlist[0]  # M1 Max  nlistmac, tlistmac =([8, 4, 2, 1],  [38.151074171066284,   75.41113114356995,   146.3512842655182,   285.11587405204773]) nlistmac = np.array(nlistmac) tlistmac = np.array(tlistmac)    plt.plot(nlist, tlist/tref, marker='.', label='Genesis4 Perlmutter') plt.plot(nlistmac, tlistmac/tref,  marker='.', label='Genesis4 M1 Max') plt.plot(nlist,  1/(nlist/nlist[0]), '--', label='ideal') plt.xscale('log') plt.yscale('log') plt.xlabel('n cores') plt.ylabel('run time (normalized)') plt.legend() Out[11]: <pre>&lt;matplotlib.legend.Legend at 0x14f2d5985eb0&gt;</pre>"},{"location":"examples/genesis4/perlmutter_benchmark/#genesis4-benchmark-on-perlmutter-nersc","title":"Genesis4 Benchmark on Perlmutter (NERSC)\u00b6","text":"<p>HPC systems often have special commands to invoke MPI jobs. NERSC uses slurm, which provides <code>srun</code> in place of <code>mpirun</code>.</p>"},{"location":"examples/genesis4/perlmutter_benchmark/#timing","title":"Timing\u00b6","text":""},{"location":"examples/genesis4/perlmutter_benchmark/#some-saved-stats","title":"Some saved stats\u00b6","text":""},{"location":"examples/genesis4/data/basic4/make_beam_files/","title":"Genesis4 Beam files","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport h5py\n\nimport matplotlib.pyplot as plt\n%config InlineBackend.figure_format = 'retina'\n</pre> import numpy as np import h5py  import matplotlib.pyplot as plt %config InlineBackend.figure_format = 'retina' In\u00a0[2]: Copied! <pre>slen = 15.0e-6\n</pre> slen = 15.0e-6 In\u00a0[3]: Copied! <pre>gamma0 = 19174.0776\n\nh = -15.0\n\nxdata = np.linspace(0, slen, 20000)\n\nydata = gamma0 + (xdata - xdata.mean()) * h * 1e6 / 0.511\n\nwith h5py.File(\"beam_gamma.h5\", \"w\") as file:\n        file[\"s\"] = xdata\n        file[\"gamma\"] = ydata\n</pre> gamma0 = 19174.0776  h = -15.0  xdata = np.linspace(0, slen, 20000)  ydata = gamma0 + (xdata - xdata.mean()) * h * 1e6 / 0.511  with h5py.File(\"beam_gamma.h5\", \"w\") as file:         file[\"s\"] = xdata         file[\"gamma\"] = ydata In\u00a0[4]: Copied! <pre>plt.plot(xdata, ydata)\n</pre> plt.plot(xdata, ydata) Out[4]: <pre>[&lt;matplotlib.lines.Line2D at 0x12077d4c0&gt;]</pre> In\u00a0[5]: Copied! <pre>sigma_t = 2.0e-6\nt0 = slen / 2.0\n\ncurr0 = 3000.0\n\nxdata = np.linspace(0, slen, 20000)\nydata = curr0 * np.exp(-(xdata - t0)**2 / 2.0 / sigma_t**2)\n\nwith h5py.File(\"beam_current.h5\", \"w\") as file:\n        file[\"s\"] = xdata\n        file[\"current\"] = ydata\n</pre> sigma_t = 2.0e-6 t0 = slen / 2.0  curr0 = 3000.0  xdata = np.linspace(0, slen, 20000) ydata = curr0 * np.exp(-(xdata - t0)**2 / 2.0 / sigma_t**2)  with h5py.File(\"beam_current.h5\", \"w\") as file:         file[\"s\"] = xdata         file[\"current\"] = ydata In\u00a0[6]: Copied! <pre>plt.plot(xdata, ydata)\n</pre> plt.plot(xdata, ydata) Out[6]: <pre>[&lt;matplotlib.lines.Line2D at 0x121088700&gt;]</pre> In\u00a0[7]: Copied! <pre># In input file\nlambda0 = 1.3789244869952112e-10 \ngamma0 = 19174.0776\n# lat file\nlambdau=0.026\naw=1.7017\n\nK = aw * np.sqrt(2)\nlambda_res = lambdau / (2 * gamma0**2) * ( 1 + K**2/2)\n\n\nlambda0, lambda_res, lambda_res/lambda0\n</pre> # In input file lambda0 = 1.3789244869952112e-10  gamma0 = 19174.0776 # lat file lambdau=0.026 aw=1.7017  K = aw * np.sqrt(2) lambda_res = lambdau / (2 * gamma0**2) * ( 1 + K**2/2)   lambda0, lambda_res, lambda_res/lambda0 Out[7]: <pre>(1.3789244869952112e-10, 1.3775556006924946e-10, 0.9990072797200813)</pre>"},{"location":"examples/genesis4/data/basic4/make_beam_files/#genesis4-beam-files","title":"Genesis4 Beam files\u00b6","text":""},{"location":"examples/genesis4/data/basic4/make_beam_files/#gamma-array","title":"Gamma array\u00b6","text":""},{"location":"examples/genesis4/data/basic4/make_beam_files/#current-array","title":"Current array\u00b6","text":""},{"location":"examples/genesis4/data/basic4/make_beam_files/#resonance","title":"Resonance\u00b6","text":"<p><code>lambda0</code> in the input file has been adjusted to account for SASE detuning</p>"}]}